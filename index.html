<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NyxMesh ‚Ä¢ Distributed Browser Computing Platform (Manual WebRTC Demo)</title>
<style>
  :root{
    --bg:#0a0a0f;--panel:#141420;--ink:#f8f9fa;--muted:#8892b0;--accent:#6366f1;--accent-2:#10b981;
    --accent-hover:#818cf8;--good:#34d399;--warn:#fbbf24;--bad:#f87171;--line:#374151;--chip:#1f2937;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;font:14px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
    background:radial-gradient(1200px 600px at 20% 0%,#1e1b4b 0%,var(--bg) 70%);color:var(--ink);
    display:flex;justify-content:center;padding:20px
  }
  .container{width:100%;max-width:1400px;display:grid;grid-template-columns:500px 1fr;gap:24px}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:16px;padding:20px;backdrop-filter:blur(12px)}
  .hero-card{background:linear-gradient(135deg, rgba(99,102,241,0.1), rgba(16,185,129,0.1));border:1px solid rgba(99,102,241,0.3)}
  h1{margin:0 0 12px;font-size:24px;font-weight:700;background:linear-gradient(135deg, #6366f1, #10b981);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
  h2{margin:20px 0 12px;font-size:18px;color:var(--ink);font-weight:600}
  h3{margin:12px 0 8px;font-size:16px;color:var(--muted);font-weight:500}
  .subtitle{color:var(--muted);font-size:16px;margin-bottom:20px;line-height:1.6}
  .value-prop{background:rgba(99,102,241,0.1);border:1px solid rgba(99,102,241,0.2);border-radius:12px;padding:16px;margin:16px 0}
  .value-prop strong{color:var(--accent)}
  .metrics-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin:16px 0}
  .metric{background:var(--chip);border:1px solid var(--line);border-radius:12px;padding:16px;text-align:center}
  .metric-label{font-size:12px;text-transform:uppercase;letter-spacing:1px;color:var(--muted);margin-bottom:8px}
  .metric-value{font-size:28px;font-weight:800;color:var(--ink)}
  .metric-unit{font-size:14px;color:var(--muted);margin-left:4px}
  .status-badge{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border-radius:20px;font-size:12px;font-weight:600}
  .status-idle{background:rgba(139,92,246,0.2);color:#a78bfa}
  .status-active{background:rgba(34,197,94,0.2);color:#4ade80}
  .status-connecting{background:rgba(251,191,36,0.2);color:#fbbf24}
  .btn{background:var(--accent);color:white;border:0;padding:12px 20px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.2s;font-size:14px}
  .btn:hover{background:var(--accent-hover);transform:translateY(-1px)}
  .btn-secondary{background:var(--chip);color:var(--ink);border:1px solid var(--line)}
  .btn-success{background:var(--good);color:#0f172a}
  .btn:disabled{opacity:.6;cursor:not-allowed;transform:none}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:16px 0}
  input,select,textarea{background:var(--chip);color:var(--ink);border:1px solid var(--line);border-radius:8px;padding:10px 12px;font-size:14px;width:100%}
  .input-group{display:grid;grid-template-columns:1fr;gap:8px;align-items:center}
  canvas{width:100%;height:auto;background:var(--bg);border:1px solid var(--line);border-radius:12px;box-shadow:inset 0 2px 4px rgba(0,0,0,0.1)}
  .worker-list{display:flex;flex-direction:column;gap:8px;margin-top:12px}
  .worker{display:grid;grid-template-columns:1fr auto auto auto;gap:12px;align-items:center;padding:12px;border:1px solid var(--line);border-radius:10px;background:rgba(31,41,55,0.5)}
  .worker-id{font-family:ui-monospace,monospace;font-size:12px}
  .worker-status{font-size:11px;color:var(--muted)}
  .perf-badge{padding:4px 8px;border-radius:12px;font-size:11px;font-weight:600}
  .perf-excellent{background:rgba(34,197,94,0.2);color:#4ade80}
  .perf-good{background:rgba(251,191,36,0.2);color:#fbbf24}
  .perf-poor{background:rgba(239,68,68,0.2);color:#f87171}
  .roi-section{background:linear-gradient(135deg, rgba(16,185,129,0.1), rgba(6,182,212,0.1));border:1px solid rgba(16,185,129,0.3);border-radius:12px;padding:16px;margin:16px 0}
  .roi-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-top:12px}
  .roi-metric{text-align:center}
  .roi-metric .value{font-size:20px;font-weight:700;color:var(--good)}
  .roi-metric .label{font-size:12px;color:var(--muted);margin-top:4px}
  .demo-controls{background:rgba(31,41,55,0.3);border-radius:12px;padding:16px;margin:16px 0}
  .activity-log{height:140px;overflow:auto;background:var(--bg);border:1px solid var(--line);border-radius:8px;padding:12px;font-family:ui-monospace,monospace;font-size:12px;color:var(--muted)}
  .invite-section{background:rgba(99,102,241,0.1);border:1px solid rgba(99,102,241,0.2);border-radius:12px;padding:16px;margin:16px 0}
  .invite-url{font-family:ui-monospace,monospace;background:var(--bg);border:1px solid var(--line);border-radius:8px;padding:12px;word-break:break-all;margin:8px 0}
  @media (max-width: 1100px) {
    .container{grid-template-columns:1fr;gap:16px}
    .metrics-grid{grid-template-columns:1fr 1fr 1fr}
    .roi-grid{grid-template-columns:1fr 1fr}
  }
</style>
</head>
<body>
<div class="container">
  <!-- Control Panel -->
  <div class="card hero-card">
    <h1>üß¨ NyxMesh</h1>
    <div class="subtitle">Distributed Browser Computing Platform</div>

    <div class="value-prop">
      <strong>Revolutionary Approach:</strong> Transform any web browser into a compute node. No installs, no cloud infrastructure, no limits. Scale computational workloads across thousands of browsers instantly.
    </div>

    <!-- Connection Status -->
    <h3>Network Status</h3>
    <div class="status-badge status-idle" id="networkStatus">
      <span>‚ö°</span>
      <span id="statusText">Ready to Connect</span>
    </div>

    <!-- Key Metrics -->
    <div class="metrics-grid">
      <div class="metric">
        <div class="metric-label">Active Nodes</div>
        <div class="metric-value" id="nodeCount">0</div>
      </div>
      <div class="metric">
        <div class="metric-label">Compute Power</div>
        <div class="metric-value" id="computePower">0<span class="metric-unit">ops/s</span></div>
      </div>
      <div class="metric">
        <div class="metric-label">Performance Gain</div>
        <div class="metric-value" id="performanceGain">1.0<span class="metric-unit">√ó</span></div>
      </div>
      <div class="metric">
        <div class="metric-label">Cost Savings</div>
        <div class="metric-value" id="costSavings">$0<span class="metric-unit"></span></div>
      </div>
    </div>

    <!-- ROI Calculator -->
    <div class="roi-section">
      <h3 style="margin:0 0 8px;color:var(--good)">üìä Business Impact</h3>
      <div class="roi-grid">
        <div class="roi-metric">
          <div class="value" id="roiSavings">$0</div>
          <div class="label">Monthly Savings</div>
        </div>
        <div class="roi-metric">
          <div class="value" id="roiNodes">0</div>
          <div class="label">Equivalent Servers</div>
        </div>
        <div class="roi-metric">
          <div class="value" id="roiEfficiency">0%</div>
          <div class="label">Efficiency Gain</div>
        </div>
      </div>
    </div>

    <!-- Demo Controls -->
    <div class="demo-controls">
      <h3 style="margin-top:0">Demo Controls</h3>
      <div class="controls">
        <button id="startDemo" class="btn">üöÄ Start Demo Session</button>
        <button id="runOptimization" class="btn btn-success" disabled>‚ñ∂ Run Optimization</button>
        <button id="stopDemo" class="btn btn-secondary" disabled>‚èπ Stop</button>
      </div>

      <div class="input-group" style="margin-top:12px">
        <label for="problemSize">Problem Size (<span id="problemSizeValue">50</span> cities)</label>
        <input id="problemSize" type="range" min="20" max="100" value="50" />
        <label for="workloadIntensity">Workload (<span id="workloadValue">5</span>/10)</label>
        <input id="workloadIntensity" type="range" min="1" max="10" value="5" />
      </div>
    </div>

    <!-- Invite New Nodes -->
    <div class="invite-section" id="inviteSection" style="display:none">
      <h3 style="margin-top:0">üì± Add Compute Nodes</h3>
      <div class="invite-url" id="inviteUrl">Generating invite link...</div>
      <div class="controls">
        <button id="copyInvite" class="btn btn-secondary">üìã Copy Link</button>
        <button id="shareInvite" class="btn btn-secondary">üîó Share</button>
        <button id="openWorker" class="btn btn-secondary">‚ûï Add Local Node</button>
      </div>
    </div>

    <!-- Manual WebRTC (no server) -->
    <div class="invite-section" id="manualWrtc" style="margin-top:12px">
      <h3 style="margin-top:0">üõ∞ Manual WebRTC (no server)</h3>
      <div class="controls" style="margin-bottom:8px">
        <label><input type="radio" name="mrRole" value="coordinator" checked> Coordinator</label>
        <label><input type="radio" name="mrRole" value="worker"> Worker</label>
        <button id="mrCreate" class="btn">Create Offer/Answer</button>
        <button id="mrCopy" class="btn btn-secondary">üìã Copy</button>
      </div>
      <label class="mono" style="font-size:12px;color:var(--muted)">Your description (Base64)</label>
      <textarea id="mrLocal" rows="5" class="mono" placeholder="Your Base64 blob will appear here‚Ä¶" readonly></textarea>
      <label class="mono" style="font-size:12px;color:var(--muted);margin-top:8px;display:block">Peer description (paste here)</label>
      <textarea id="mrRemote" rows="5" class="mono" placeholder="Paste the other side's blob here‚Ä¶"></textarea>
      <div class="controls" style="margin-top:8px">
        <button id="mrSetRemote" class="btn btn-secondary">Set Remote</button>
        <span id="mrState" class="status-badge status-idle">idle</span>
      </div>
      <div style="font-size:12px;color:var(--muted)">Tip: run via http://localhost (not file://). On Zoom, paste blobs in chat.</div>
    </div>

    <!-- Active Nodes -->
    <h3>Compute Nodes <span id="nodeCountBadge" class="status-badge status-idle">0 active</span></h3>
    <div id="workerList" class="worker-list">
      <div style="color:var(--muted);text-align:center;padding:20px">Start demo session to see active nodes</div>
    </div>
  </div>

  <!-- Visualization Panel -->
  <div class="card">
    <h2>üéØ Live Optimization Demo</h2>
    <div class="subtitle">Traveling Salesman Problem ‚Äî Real-time distributed solving</div>

    <canvas id="problemCanvas" width="800" height="500"></canvas>

    <h3>Performance Over Time</h3>
    <canvas id="performanceChart" width="800" height="120"></canvas>
    <div style="font-size:12px;color:var(--muted);margin-top:8px">
      Solution quality improves as more nodes join the computation
    </div>

    <h3>System Activity</h3>
    <div id="activityLog" class="activity-log">
      <div style="color:var(--accent)">NyxMesh Distributed Computing Platform v2.0</div>
      <div>Ready to demonstrate browser-based distributed computing...</div>
    </div>
  </div>
</div>

<script>
'use strict';

/* ==== Helpers ==== */
function makeId(len = 16) {
  try { if (crypto?.randomUUID) return crypto.randomUUID().replace(/-/g,'').slice(0,len); } catch {}
  return (Math.random().toString(36).slice(2) + Date.now().toString(36)).slice(0, len);
}
const safeClone = (obj) => JSON.parse(JSON.stringify(obj));

/* ==== Core State ==== */
const peerId = makeId(16);
let sessionId = null;
let isCoordinator = false;
let demoRunning = false;
let optimizationRunning = false;
let optimizationInterval = null;
const nodes = new Map(); // id -> NetworkPeer (coordinator view)

/* ==== Networking config (optional) ==== */
const DEFAULT_SIGNAL_URL = (location.protocol === "https:" ? "wss://" : "ws://")
  + ((location.hostname && location.hostname !== "") ? location.hostname : "localhost")
  + ":" + ((location.port && location.port !== "") ? location.port : "8080");
let SIGNAL_URL = DEFAULT_SIGNAL_URL;
const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

/* ==== Signaling (WS + local fallback) ==== */
let signalSocket = null;
const broadcastChannel = ('BroadcastChannel' in window) ? new BroadcastChannel('nyxmesh-demo') : null;
let localFallbackMode = false;

/* ==== NetworkPeer ==== */
class NetworkPeer {
  constructor(id) {
    this.id = id;
    this.pc = null;
    this.dataChannel = null;
    this.status = 'connecting';
    this.latency = 0;
    this.operations = 0;
    this.cpu = 0;
    this._lastPing = 0;
    this._pingTimer = null;
  }
  async connect() {
    try {
      this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 });
      this.pc.onconnectionstatechange = () => {
        this.status = this.pc.connectionState;
        if (this.status === 'connected') log(`‚úÖ Peer connected: ${this.id.slice(0, 8)}`);
        renderWorkerList();
      };
      this.pc.onicecandidate = (event) => {
        if (!event.candidate) return;
        const cand = event.candidate.toJSON ? event.candidate.toJSON() : {
          candidate: event.candidate.candidate,
          sdpMid: event.candidate.sdpMid,
          sdpMLineIndex: event.candidate.sdpMLineIndex
        };
        sendSignal({ type: 'ice', to: this.id, candidate: cand });
      };
      if (isCoordinator) {
        this.dataChannel = this.pc.createDataChannel('compute', { ordered: true });
        this.setupDataChannel();
        const offer = await this.pc.createOffer();
        await this.pc.setLocalDescription(offer);
        sendSignal({ type: 'offer', to: this.id, sdp: offer });
      } else {
        this.pc.ondatachannel = (event) => { this.dataChannel = event.channel; this.setupDataChannel(); };
      }
    } catch (error) {
      log(`‚ùå Connection failed to ${this.id.slice(0, 8)}: ${error.message}`);
      this.status = 'failed';
    }
  }
  setupDataChannel() {
    this.dataChannel.onopen = () => {
      this.status = 'connected';
      log(`üîó DataChannel ready: ${this.id.slice(0, 8)}`);
      renderWorkerList();
      if (isCoordinator) this.startPingLoop();
    };
    this.dataChannel.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message);
    };
    this.dataChannel.onerror = (error) => { log(`‚ö†Ô∏è DataChannel error: ${error}`); };
  }
  startPingLoop() {
    clearInterval(this._pingTimer);
    this._pingTimer = setInterval(() => {
      if (this.dataChannel?.readyState === 'open') {
        this._lastPing = Date.now();
        this.send({ type: 'ping', timestamp: this._lastPing });
      }
    }, 5000);
  }
  handleMessage(message) {
    switch (message.type) {
      case 'ping': if (!isCoordinator) this.send({ type: 'pong', timestamp: message.timestamp }); break;
      case 'pong': if (isCoordinator) { this.latency = Date.now() - message.timestamp; renderWorkerList(); } break;
      case 'compute_task': if (!isCoordinator) this.handleComputeTask(message); break;
      case 'compute_result': if (isCoordinator) this.handleComputeResult(message); break;
    }
  }
  send(message) {
    if (this.dataChannel?.readyState === 'open') {
      this.dataChannel.send(JSON.stringify(message));
    }
  }
  handleComputeTask(message) {
    const result = performOptimizationStep(message.problemData, message.parameters);
    this.send({ type: 'compute_result', taskId: message.taskId, result });
    this.operations++; this.cpu = Math.min(100, this.cpu + Math.random() * 20);
  }
  handleComputeResult(message) {
    if (message.result && message.result.distance < bestSolution.distance) {
      bestSolution = message.result;
      drawProblem();
      log(`üéØ Better solution: ${Math.round(bestSolution.distance)} from ${this.id.slice(0, 8)}`);
    }
    computeMetrics.totalOperations++; this.operations++;
  }
  async acceptOffer(offer) {
    await this.pc.setRemoteDescription(offer);
    const answer = await this.pc.createAnswer();
    await this.pc.setLocalDescription(answer);
    sendSignal({ type: 'answer', to: this.id, sdp: answer });
  }
  async acceptAnswer(answer) { await this.pc.setRemoteDescription(answer); }
  async addIceCandidate(candidate) { try { await this.pc.addIceCandidate(candidate); } catch (e) { console.warn('Failed to add ICE candidate:', e); } }
}

/* ==== Signaling helpers ==== */
function connectToSignalServer() {
  return new Promise((resolve, reject) => {
    try {
      signalSocket = new WebSocket(SIGNAL_URL);
      signalSocket.onopen = () => {
        updateNetworkStatus('active', 'Connected to Signal Server');
        log(`üîó Connected to signaling server: ${SIGNAL_URL}`);
        sendSignal({ type: 'join', sessionId, peerId, role: isCoordinator ? 'coordinator' : 'worker' });
        resolve();
      };
      signalSocket.onmessage = (event) => {
        try { const message = JSON.parse(event.data); handleSignalMessage(message); }
        catch (error) { console.warn('Invalid signal message:', error); }
      };
      signalSocket.onerror = () => { reject(new Error('WebSocket connection failed')); };
      signalSocket.onclose = () => {
        if (demoRunning) {
          updateNetworkStatus('connecting', 'Reconnecting...');
          log('‚ö†Ô∏è Signal server disconnected, attempting reconnect...');
          setTimeout(() => { if (demoRunning) connectToSignalServer().catch(() => {}); }, 3000);
        }
      };
    } catch (error) {
      // If constructor throws (e.g., file://), fallback immediately
      if (broadcastChannel) {
        localFallbackMode = true;
        updateNetworkStatus('active', 'Local Demo Mode');
        log('üì± Using local BroadcastChannel (no server needed)');
        broadcastChannel.onmessage = (event) => handleSignalMessage(event.data);
        resolve();
      } else { reject(error); }
    }
  }).catch(() => {
    // Fallback if WS failed asynchronously
    if (broadcastChannel) {
      localFallbackMode = true;
      updateNetworkStatus('active', 'Local Demo Mode');
      log('üì± Using local BroadcastChannel (no server needed)');
      broadcastChannel.onmessage = (event) => handleSignalMessage(event.data);
    }
  });
}

function sendSignal(message) {
  // Ensure structured-clone-safe payloads
  let m = { ...message, from: peerId, sessionId };
  if (m.type === 'ice' && m.candidate && typeof m.candidate.toJSON === 'function') {
    m.candidate = m.candidate.toJSON();
  }
  // Deep clone to avoid DOM objects slipping through
  m = safeClone(m);
  if (localFallbackMode && broadcastChannel) {
    broadcastChannel.postMessage(m);
  } else if (signalSocket?.readyState === WebSocket.OPEN) {
    signalSocket.send(JSON.stringify(m));
  }
}

async function handleSignalMessage(message) {
  if (message.sessionId !== sessionId) return;
  switch (message.type) {
    case 'peer_joined': {
      // In local bc-mode, skip auto-RTC; use Manual WebRTC panel instead.
      if (localFallbackMode) {
        log('üì± Peer joined (local mode) ‚Äî use Manual WebRTC to connect');
        updateMetrics();
        break;
      }
      if (isCoordinator && message.from !== peerId) {
        log(`üì± New peer joined: ${message.from.slice(0, 8)}`);
        const peer = new NetworkPeer(message.from);
        nodes.set(message.from, peer);
        await peer.connect();
        updateMetrics();
      }
      break;
    }
    case 'offer':
      if (!isCoordinator && message.to === peerId) {
        const peer = new NetworkPeer(message.from);
        nodes.set(message.from, peer);
        await peer.connect();
        await peer.acceptOffer(message.sdp);
      }
      break;
    case 'answer':
      if (isCoordinator && message.to === peerId) {
        const peer = nodes.get(message.from);
        if (peer) await peer.acceptAnswer(message.sdp);
      }
      break;
    case 'ice': {
      const peer = nodes.get(message.from);
      if (peer && message.to === peerId) await peer.addIceCandidate(message.candidate);
      break;
    }
    case 'peer_left':
      if (nodes.has(message.from)) {
        nodes.delete(message.from);
        log(`üì± Peer left: ${message.from.slice(0, 8)}`);
        updateMetrics(); renderWorkerList();
      }
      break;
  }
}

/* ==== Optimization State ==== */
let problemData = [];
let bestSolution = { route: null, distance: Infinity };
let performanceHistory = [];
let computeMetrics = { totalOperations: 0, startTime: 0, baselinePerformance: 0 };

/* ==== DOM ==== */
const elements = {
  startDemo: document.getElementById('startDemo'),
  runOptimization: document.getElementById('runOptimization'),
  stopDemo: document.getElementById('stopDemo'),
  networkStatus: document.getElementById('networkStatus'),
  statusText: document.getElementById('statusText'),
  nodeCount: document.getElementById('nodeCount'),
  computePower: document.getElementById('computePower'),
  performanceGain: document.getElementById('performanceGain'),
  costSavings: document.getElementById('costSavings'),
  inviteSection: document.getElementById('inviteSection'),
  inviteUrl: document.getElementById('inviteUrl'),
  workerList: document.getElementById('workerList'),
  problemCanvas: document.getElementById('problemCanvas'),
  performanceChart: document.getElementById('performanceChart'),
  activityLog: document.getElementById('activityLog'),
  problemSize: document.getElementById('problemSize'),
  workloadIntensity: document.getElementById('workloadIntensity'),
  problemSizeValue: document.getElementById('problemSizeValue'),
  workloadValue: document.getElementById('workloadValue'),
  nodeCountBadge: document.getElementById('nodeCountBadge')
};
const problemCtx = elements.problemCanvas.getContext('2d');
const chartCtx = elements.performanceChart.getContext('2d');

/* ==== UI Helpers ==== */
function log(message) {
  const timestamp = new Date().toLocaleTimeString();
  const logEntry = document.createElement('div');
  logEntry.innerHTML = `<span style="color:var(--muted)">[${timestamp}]</span> ${message}`;
  elements.activityLog.appendChild(logEntry);
  elements.activityLog.scrollTop = elements.activityLog.scrollHeight;
}
function updateNetworkStatus(status, text) {
  elements.networkStatus.className = `status-badge status-${status}`;
  elements.statusText.textContent = text;
}
function updateMetrics() {
  const nodeCount = nodes.size;
  const computePower = computeMetrics.totalOperations / Math.max(1, (Date.now() - computeMetrics.startTime) / 1000);
  const performanceGain = nodeCount > 0 ? Math.max(1, nodeCount * 0.8) : 1;
  const costSavings = Math.round(computeMetrics.totalOperations * 0.0001 * nodeCount);

  elements.nodeCount.textContent = nodeCount;
  elements.computePower.textContent = Math.round(computePower);
  elements.performanceGain.textContent = `${performanceGain.toFixed(1)}`;
  elements.costSavings.textContent = `$${costSavings}`;

  document.getElementById('roiSavings').textContent = `$${Math.round(costSavings * 30)}`;
  document.getElementById('roiNodes').textContent = Math.round(nodeCount * 0.1);
  document.getElementById('roiEfficiency').textContent = `${Math.round((performanceGain - 1) * 100)}`;

  elements.nodeCountBadge.textContent = `${nodeCount} active`;
  elements.nodeCountBadge.className = `status-badge ${nodeCount > 0 ? 'status-active' : 'status-idle'}`;
}
function renderWorkerList() {
  if (nodes.size === 0) {
    elements.workerList.innerHTML = '<div style="color:var(--muted);text-align:center;padding:20px">No active nodes</div>';
    return;
  }
  elements.workerList.innerHTML = '';
  for (const [id, node] of nodes) {
    const workerEl = document.createElement('div');
    workerEl.className = 'worker';
    const latency = node.latency || 0;
    const perfClass = latency < 100 ? 'perf-excellent' : latency < 300 ? 'perf-good' : 'perf-poor';
    workerEl.innerHTML = `
      <div>
        <div class="worker-id">${(id||'peer').toString().slice(0,8)}</div>
        <div class="worker-status">${node.status || 'active'}</div>
      </div>
      <div class="perf-badge ${perfClass}">${latency}ms</div>
      <div class="perf-badge">${node.operations || 0} ops</div>
      <div class="perf-badge">CPU ${node.cpu || '‚Äî'}%</div>
    `;
    elements.workerList.appendChild(workerEl);
  }
}

/* ==== Problem generation / drawing ==== */
function generateProblem(size) {
  const canvas = elements.problemCanvas;
  const width = canvas.width, height = canvas.height;
  problemData = [];
  for (let i = 0; i < size; i++) {
    problemData.push({ x: Math.random() * (width - 100) + 50, y: Math.random() * (height - 100) + 50 });
  }
  bestSolution = { route: null, distance: Infinity };
  performanceHistory = [];
  drawProblem();
}
function drawProblem() {
  const ctx = problemCtx, canvas = elements.problemCanvas;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#f8f9fa';
  for (const city of problemData) { ctx.beginPath(); ctx.arc(city.x, city.y, 4, 0, Math.PI * 2); ctx.fill(); }

  if (bestSolution.route) {
    ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 2; ctx.beginPath();
    const route = bestSolution.route;
    ctx.moveTo(problemData[route[0]].x, problemData[route[0]].y);
    for (let i = 1; i < route.length; i++) ctx.lineTo(problemData[route[i]].x, problemData[route[i]].y);
    ctx.lineTo(problemData[route[0]].x, problemData[route[0]].y);
    ctx.stroke();
  }
  ctx.fillStyle = '#8892b0'; ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
  ctx.fillText(`${problemData.length} cities`, 20, 30);
  if (bestSolution.distance !== Infinity) ctx.fillText(`Best distance: ${Math.round(bestSolution.distance)}`, 20, 50);
}
function drawPerformanceChart() {
  if (performanceHistory.length < 2) return;
  const ctx = chartCtx, canvas = elements.performanceChart, width = canvas.width, height = canvas.height;
  ctx.clearRect(0, 0, width, height);
  const minDistance = Math.min(...performanceHistory.map(p => p.distance));
  const maxDistance = Math.max(...performanceHistory.map(p => p.distance));
  const range = maxDistance - minDistance || 1;
  ctx.strokeStyle = '#10b981'; ctx.lineWidth = 2; ctx.beginPath();
  performanceHistory.forEach((point, index) => {
    const x = (index / (performanceHistory.length - 1)) * (width - 40) + 20;
    const y = height - 20 - ((point.distance - minDistance) / range) * (height - 40);
    if (index === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();
}

/* ==== Simulation + dispatch ==== */
function simulateOptimizationStep() {
  if (!optimizationRunning || problemData.length === 0) return;

  const improvement = Math.random() * 0.02 * Math.max(1, nodes.size);
  const baseline = calculateInitialDistance();
  const newDistance = bestSolution.distance === Infinity
    ? baseline
    : Math.max(bestSolution.distance * (1 - improvement), baseline * 0.3);

  if (newDistance < bestSolution.distance) {
    bestSolution.distance = newDistance;
    bestSolution.route = generateRandomRoute();
    performanceHistory.push({ time: Date.now(), distance: newDistance, nodes: nodes.size });
    drawProblem(); drawPerformanceChart();
    computeMetrics.totalOperations += nodes.size || 1;
    updateMetrics();
    log(`Improved solution found: ${Math.round(newDistance)} (${nodes.size} nodes active)`);
  }

  for (const [, node] of nodes) {
    node.operations = (node.operations || 0) + Math.floor(Math.random() * 10);
    node.cpu = Math.round(20 + Math.random() * 60);
  }
  renderWorkerList();
}
function dispatchComputeTasks() {
  if (!isCoordinator || !problemData.length) return;
  const params = { populationSize: 50 + Math.floor(Math.random()*20), generations: 15 + Math.floor(Math.random()*10), mutationRate: 0.1 };
  for (const [, peer] of nodes) {
    if (peer?.dataChannel?.readyState === 'open') {
      peer.send({ type: 'compute_task', taskId: (Date.now() + '-' + Math.random().toString(36).slice(2,6)), problemData, parameters: params });
    }
  }
}
function calculateInitialDistance() {
  if (problemData.length === 0) return 0;
  let total = 0;
  for (let i = 0; i < problemData.length; i++) {
    const a = problemData[i], b = problemData[(i + 1) % problemData.length];
    total += Math.hypot(b.x - a.x, b.y - a.y);
  }
  return total;
}
function generateRandomRoute() {
  const n = problemData.length;
  const route = Array.from({ length: n }, (_, i) => i);
  for (let i = n - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [route[i], route[j]] = [route[j], route[i]]; }
  return route;
}

/* ==== GA worker (runs on workers for real compute) ==== */
function shuffleRange(n){
  const arr = Array.from({length:n}, (_,i)=>i);
  for (let i=n-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr;
}
function createRandomRoute(n){ return shuffleRange(n); }
function calculateRouteDistance(route, cities) {
  let total = 0;
  for (let i = 0; i < route.length; i++) {
    const a = cities[route[i]], b = cities[route[(i+1)%route.length]];
    total += Math.hypot(b.x - a.x, b.y - a.y);
  }
  return total;
}
function selectParent(population, fitness) {
  const k = 3; let bestIdx = Math.floor(Math.random()*population.length), bestFit = fitness[bestIdx];
  for (let i=1;i<k;i++){ const idx=Math.floor(Math.random()*population.length); if (fitness[idx] > bestFit){ bestIdx=idx; bestFit=fitness[idx]; } }
  return population[bestIdx];
}
function crossover(p1, p2) {
  const n = p1.length; const start = Math.floor(Math.random()*n); const end = start + Math.floor(Math.random()*(n-start));
  const child = new Array(n).fill(-1); const used = new Set();
  for (let i=start;i<=end;i++){ child[i]=p1[i]; used.add(p1[i]); }
  let pos = (end+1)%n;
  for (let i=0;i<n;i++){ const g = p2[(end+1+i)%n]; if (!used.has(g)){ child[pos]=g; pos=(pos+1)%n; } }
  return child;
}
function mutate(route){ const r = route.slice(); const i=Math.floor(Math.random()*r.length), j=Math.floor(Math.random()*r.length); [r[i],r[j]]=[r[j],r[i]]; return r; }
function performOptimizationStep(cities, params) {
  const { populationSize = 50, generations = 20, mutationRate = 0.1 } = params || {};
  let population = []; for (let i = 0; i < populationSize; i++) population.push(createRandomRoute(cities.length));
  let bestRoute = null, bestDistance = Infinity;

  for (let gen = 0; gen < generations; gen++) {
    const fitness = population.map(route => 1 / calculateRouteDistance(route, cities));
    for (let i = 0; i < population.length; i++) {
      const d = calculateRouteDistance(population[i], cities);
      if (d < bestDistance) { bestDistance = d; bestRoute = population[i].slice(); }
    }
    const next = [];
    next.push(bestRoute.slice());
    while (next.length < populationSize) {
      const p1 = selectParent(population, fitness);
      const p2 = selectParent(population, fitness);
      let child = crossover(p1, p2);
      if (Math.random() < mutationRate) child = mutate(child);
      next.push(child);
    }
    population = next;
  }
  return { route: bestRoute, distance: bestDistance, generations, populationSize };
}

/* ==== Demo session management ==== */
async function startDemoSession() {
  try {
    sessionId = makeId(24);
    isCoordinator = true; demoRunning = true;
    updateNetworkStatus('connecting', 'Starting Session...');
    try {
      await connectToSignalServer();
      log('üöÄ Networking hooks ready');
      log(`üì° Signaling: ${localFallbackMode ? 'Local BroadcastChannel' : 'WebSocket Server'}`);
    } catch (error) {
      updateNetworkStatus('idle', 'No signaling server (okay)');
      log('‚ÑπÔ∏è No signaling server detected ‚Äî use Manual WebRTC panel');
    }
    log(`Session ID: ${sessionId.slice(0, 8)}`);
    const inviteUrl = `${window.location.origin}${window.location.pathname}#join=${sessionId}`;
    elements.inviteUrl.textContent = inviteUrl;
    elements.inviteSection.style.display = 'block';

    elements.startDemo.disabled = true;
    elements.runOptimization.disabled = false;
    elements.stopDemo.disabled = false;
    computeMetrics.startTime = Date.now();
  } catch (error) {
    updateNetworkStatus('idle', 'Failed to Start');
    log(`‚ùå Failed to start session: ${error.message}`);
    elements.startDemo.disabled = false;
  }
}
async function joinAsWorker(joinSessionId) {
  try {
    sessionId = joinSessionId; isCoordinator = false; demoRunning = true;
    updateNetworkStatus('connecting', 'Joining Session...');
    log(`üîó Joining session: ${sessionId.slice(0, 8)}`);
    await connectToSignalServer();
    sendSignal({ type: 'peer_joined', from: peerId });
    updateNetworkStatus('active', 'Connected as Compute Node');
    log('‚úÖ Successfully joined as compute node');

    elements.startDemo.style.display = 'none';
    elements.runOptimization.style.display = 'none';
    elements.stopDemo.style.display = 'none';
    elements.inviteSection.style.display = 'none';

    const workerStatus = document.createElement('div');
    workerStatus.className = 'value-prop';
    workerStatus.innerHTML = '<strong>Worker Node Active:</strong> This browser is contributing compute power to the distributed network.';
    document.querySelector('.hero-card').insertBefore(workerStatus, document.querySelector('h3'));
  } catch (error) {
    updateNetworkStatus('idle', 'Failed to Join');
    log(`‚ùå Failed to join session: ${error.message}`);
  }
}
function stopDemoSession() {
  demoRunning = false;
  optimizationRunning = false;
  if (optimizationInterval) {
    clearInterval(optimizationInterval);
    optimizationInterval = null;
  }
  updateNetworkStatus('idle', 'Session Ended');
  log('üõë Demo session stopped');
  elements.startDemo.disabled = false;
  elements.runOptimization.disabled = true;
  elements.runOptimization.textContent = '‚ñ∂ Run Optimization';
  elements.stopDemo.disabled = true;
  elements.inviteSection.style.display = 'none';
  nodes.clear();
  updateMetrics(); renderWorkerList();
}

function startOptimization() {
  if (optimizationRunning) {
    // Stop the current optimization
    optimizationRunning = false;
    if (optimizationInterval) {
      clearInterval(optimizationInterval);
      optimizationInterval = null;
    }
    elements.runOptimization.textContent = '‚ñ∂ Run Optimization';
    elements.runOptimization.className = 'btn btn-success';
    log('‚è∏ Optimization stopped');
    return;
  }

  const problemSize = parseInt(elements.problemSize.value, 10);
  generateProblem(problemSize);
  optimizationRunning = true;
  elements.runOptimization.textContent = '‚è∏ Stop Optimization';
  elements.runOptimization.className = 'btn btn-secondary';

  log(`üéØ Starting optimization: ${problemSize} cities`);
  log(`Workload intensity: ${elements.workloadIntensity.value}/10`);

  optimizationInterval = setInterval(() => {
    if (!optimizationRunning) {
      clearInterval(optimizationInterval);
      optimizationInterval = null;
      elements.runOptimization.textContent = '‚ñ∂ Run Optimization';
      elements.runOptimization.className = 'btn btn-success';
      return;
    }
    dispatchComputeTasks();
    if (nodes.size === 0) simulateOptimizationStep(); // local sim if no workers
  }, 200);
}

function addSimulatedNode(id) {
  if (!demoRunning) return;
  const node = {
    id: id || makeId(8),
    status: 'connected',
    latency: Math.round(50 + Math.random() * 200),
    operations: 0,
    cpu: Math.round(10 + Math.random() * 30)
  };
  nodes.set(node.id, node);
  updateMetrics(); renderWorkerList();
  log(`üì± Node joined: ${node.id} (${node.latency}ms latency)`);
}

/* ==== Events ==== */
elements.startDemo.addEventListener('click', startDemoSession);
elements.stopDemo.addEventListener('click', stopDemoSession);
elements.runOptimization.addEventListener('click', startOptimization);

document.getElementById('copyInvite').addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(elements.inviteUrl.textContent);
    log('üìã Invite link copied - share this with other computers!');
    const instruction = document.createElement('div');
    instruction.style.cssText = 'position:fixed;top:20px;right:20px;background:var(--good);color:white;padding:12px;border-radius:8px;z-index:1000;';
    instruction.innerHTML = '‚úÖ Link copied! Share with other devices to add compute power.';
    document.body.appendChild(instruction);
    setTimeout(() => instruction.remove(), 3000);
  } catch { log('‚ùå Failed to copy link'); }
});
document.getElementById('shareInvite').addEventListener('click', async () => {
  const url = elements.inviteUrl.textContent;
  if (navigator.share) {
    try {
      await navigator.share({ title: 'Join NyxMesh Computing Demo', text: 'Help demonstrate distributed browser computing by joining this session', url });
      log('üì§ Invite shared successfully');
    } catch (error) {
      if (error.name !== 'AbortError') {
        log('‚ùå Share failed, copying to clipboard instead');
        navigator.clipboard.writeText(url);
      }
    }
  } else { showQRCode(url); }
});
function showQRCode(url) {
  const modal = document.createElement('div');
  modal.style.cssText = `position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 2000;`;
  const content = document.createElement('div');
  content.style.cssText = `background: var(--panel); border: 1px solid var(--line); border-radius: 16px; padding: 24px; text-align: center; max-width: 400px;`;
  content.innerHTML = `
    <h3 style="margin: 0 0 16px; color: var(--ink);">üì± Scan to Join</h3>
    <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}" style="border-radius: 8px; background: white; padding: 8px;" alt="QR Code">
    <div style="margin: 16px 0; font-family: monospace; font-size: 12px; word-break: break-all; color: var(--muted);">${url}</div>
    <button class="btn btn-secondary" onclick="this.closest('[style*=fixed]').remove()">Close</button>`;
  modal.appendChild(content); document.body.appendChild(modal); log('üì± QR code displayed - scan with phone/tablet to join');
}
document.getElementById('openWorker').addEventListener('click', (e) => {
  const url = elements.inviteUrl.textContent;
  if (e.shiftKey) {
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        const w = window.open(url, `_blank${i}`);
        if (w) log(`üöÄ Opened worker tab ${i + 1}/3`);
      }, i * 500);
    }
  } else {
    const w = window.open(url, '_blank');
    if (w) log('üöÄ Opened worker tab - it will auto-connect');
    else log('‚ùå Popup blocked - please allow popups or copy the link manually');
  }
});

// hash join (optional server signaling path)
window.addEventListener('hashchange', handleHashChange);
window.addEventListener('load', handleHashChange);
function handleHashChange() {
  const hash = window.location.hash.slice(1);
  const joinMatch = hash.match(/join=([^&]+)/);
  if (joinMatch && !demoRunning) joinAsWorker(joinMatch[1]);
}

// sliders
elements.problemSize.addEventListener('input', (e) => { elements.problemSizeValue.textContent = e.target.value; });
elements.workloadIntensity.addEventListener('input', (e) => { elements.workloadValue.textContent = e.target.value; });

// keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) {
    switch (e.key) {
      case '1': e.preventDefault(); if (!demoRunning) elements.startDemo.click(); break;
      case '2': e.preventDefault(); if (demoRunning) elements.runOptimization.click(); break;
      case '3': e.preventDefault(); if (demoRunning) document.getElementById('openWorker').click(); break;
    }
  }
});

// metric animation
const animateMetricChange = (element) => { element.style.transform = 'scale(1.1)'; element.style.transition = 'transform 0.2s'; setTimeout(() => { element.style.transform = 'scale(1)'; }, 200); };
const originalUpdateMetrics = updateMetrics;
updateMetrics = function() { const oldNodeCount = elements.nodeCount.textContent; originalUpdateMetrics(); if (elements.nodeCount.textContent !== oldNodeCount) animateMetricChange(elements.nodeCount); };

/* ==== Manual WebRTC (copy/paste) ==== */
const mr = { role: 'coordinator', pc: null, dc: null, gatherTimer: null, peerId: 'manual-' + makeId(8) };
const MR_CONFIG = { iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 };
const mrPack = (d)=> btoa(unescape(encodeURIComponent(JSON.stringify(d))));
const mrUnpack = (b64)=> JSON.parse(decodeURIComponent(escape(atob(b64.replace(/\s+/g,'')))));
const mrRoleInputs = document.querySelectorAll('input[name="mrRole"]');
const mrLocal = document.getElementById('mrLocal');
const mrRemote = document.getElementById('mrRemote');
const mrState = document.getElementById('mrState');

mrRoleInputs.forEach(r=>r.addEventListener('change',()=>{ mr.role=r.value; mrReset(); }));
document.getElementById('mrCreate').onclick = async () => {
  try{
    if(!mr.pc) mrSetupPC();
    if(mr.role==='coordinator'){
      const offer = await mr.pc.createOffer();
      await mr.pc.setLocalDescription(offer);
      mrSetState('Gathering ICE‚Ä¶','connecting');
    } else {
      if (!mr.pc.remoteDescription){ mrSetState('Set remote offer first','idle'); return; }
      const answer = await mr.pc.createAnswer();
      await mr.pc.setLocalDescription(answer);
      mrSetState('Gathering ICE‚Ä¶','connecting');
    }
  }catch(e){ console.error(e); mrSetState('Error creating SDP','idle'); }
};
document.getElementById('mrCopy').onclick = async () => {
  const t = mrLocal.value.trim(); if(!t) return;
  try{ await navigator.clipboard.writeText(t); mrSetState('Copied ‚úì','active'); }
  catch{ mrSetState('Copy failed','idle'); }
};
document.getElementById('mrSetRemote').onclick = async () => {
  try{
    const raw = mrRemote.value.trim();
    if(!raw){ mrSetState('Paste peer blob','idle'); return; }
    let desc;
    if (/^[A-Za-z0-9+/=\s]+$/.test(raw) && !/^\s*v=0/.test(raw)) desc = mrUnpack(raw);
    else if (/^\s*\{/.test(raw)) desc = JSON.parse(raw);
    else if (/^\s*v=0/.test(raw)) desc = { type: (mr.role==='coordinator'?'answer':'offer'), sdp: raw };
    else throw new Error('Bad blob');

    if(!mr.pc) mrSetupPC();
    await mr.pc.setRemoteDescription(desc);
    mrSetState(`Remote ${desc.type} set`,'connecting');
  }catch(e){ console.error(e); mrSetState('Invalid blob','idle'); }
};
function mrSetState(text, kind='idle'){ mrState.textContent = text; mrState.className = `status-badge status-${kind}`; }
function mrReset(){ try{ mr.dc && mr.dc.close(); }catch{} try{ mr.pc && mr.pc.close(); }catch{} mr.pc = null; mr.dc = null; mrLocal.value=''; mrRemote.value=''; mrSetState('idle','idle'); }
function mrSetupPC(){
  mr.pc = new RTCPeerConnection(MR_CONFIG);
  let gatherTimer=null;
  mr.pc.onicecandidate = () => {
    if (gatherTimer) clearTimeout(gatherTimer);
    gatherTimer = setTimeout(()=>{ if (mr.pc.localDescription) mrLocal.value = mrPack(mr.pc.localDescription); }, 250);
  };
  mr.pc.onconnectionstatechange = ()=>{
    const s = mr.pc.connectionState;
    if (s==='connected'){ mrSetState('Connected ‚úì','active'); }
    else if (['failed','closed'].includes(s)){ mrSetState(s,'idle'); }
  };
  if (mr.role==='coordinator'){
    mr.dc = mr.pc.createDataChannel('compute', { ordered:true });
    mrWireDC(mr.dc);
  } else {
    mr.pc.ondatachannel = (ev)=>{ mr.dc = ev.channel; mrWireDC(mr.dc); };
  }
}
function mrWireDC(channel){
  channel.onopen = ()=>{
    const id = mr.peerId;
    const p = new NetworkPeer(id);
    p.pc = mr.pc; p.dataChannel = channel; p.setupDataChannel();
    if (isCoordinator){
      nodes.set(id, p); updateMetrics(); renderWorkerList();
      log(`üì± Manual WebRTC node connected: ${id}`);
    } else {
      log('‚úÖ DataChannel open (worker)');
    }
  };
  channel.onclose = ()=>{
    if (isCoordinator && nodes.has(mr.peerId)) {
      nodes.delete(mr.peerId); updateMetrics(); renderWorkerList();
    }
    mrSetState('Disconnected','idle');
  };
  channel.onerror = (e)=>{ console.error('DC error', e); mrSetState('DC error','idle'); };
}

/* ==== Init ==== */
log('üß¨ NyxMesh platform ready');
log('Click "Start Demo Session" then use the Manual WebRTC panel to connect peers.');

// periodic metric refresh & light churn simulation
setInterval(() => {
  if (demoRunning) {
    updateMetrics();
    if (Math.random() < 0.05 && nodes.size > 2) {
      const nodeIds = Array.from(nodes.keys());
      const randomNode = nodeIds[Math.floor(Math.random() * nodeIds.length)];
      nodes.delete(randomNode);
      log(`üì± Node disconnected: ${randomNode}`);
      updateMetrics(); renderWorkerList();
      setTimeout(() => { if (demoRunning) addSimulatedNode(randomNode); }, 3000 + Math.random() * 2000);
    }
  }
}, 3000);
</script>
</body>
</html>