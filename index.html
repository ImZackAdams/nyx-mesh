<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NyxMesh â€¢ P2P Fractal Renderer (WS Relay)</title>
<style>
  :root{--bg:#0b0b0f;--panel:#16161d;--ink:#eaeaf2;--muted:#a7a7b3;--accent:#9b5cff;--accent-hover:#b47dff;}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:radial-gradient(1200px 600px at 10% 0%,#141421 0%,var(--bg) 60%);color:var(--ink);display:flex;justify-content:center;padding:18px}
  .wrap{width:100%;max-width:1100px;display:grid;grid-template-columns:360px 1fr;gap:14px}
  .card{background:var(--panel);border:1px solid #222231;border-radius:14px;padding:14px}
  h1{margin:0 0 8px;font-size:18px} h2{margin:0 0 10px;font-size:15px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);color:#0b0b0f;border:0;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;transition:.2s}
  .btn:hover{background:var(--accent-hover);transform:translateY(-1px)}
  .btn:disabled{opacity:0.5;cursor:not-allowed}
  .btn.secondary{background:#2a2a38;color:var(--ink);border:1px solid #333349}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  input,select,textarea{width:100%;background:#0f0f16;color:#0ef;border:1px solid #282838;border-radius:8px;padding:10px}
  .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #2a2a3a;padding:4px 0}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#24243a;color:var(--ink);font-size:12px}
  .ok{background:#1d3d23;color:#7dff8b}.warn{background:#3d3d1d;color:#ffe57d}.bad{background:#3d1d1d;color:#ff7d7d}
  .log{height:220px;overflow:auto;background:#0e0e15;border:1px solid #242436;border-radius:8px;padding:8px}
  .status{margin-top:10px;padding:8px;border-radius:8px;background:#1a1a24;border:1px solid #2a2a3a;font-size:13px}
  canvas{width:100%;height:auto;background:#0c0c14;border:1px solid #242436;border-radius:10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  label small{color:var(--muted);display:block;margin-top:4px}
  @media (max-width: 768px) {.wrap{grid-template-columns:1fr}.card:first-child{order:2}.card:last-child{order:1}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>ðŸš€ NyxMesh (WS Relay)</h1>
    <div class="kv"><span>Connection</span><span id="pc" class="pill">idle</span></div>
    <div class="kv"><span>ICE</span><span id="ice" class="pill">idle</span></div>
    <div class="kv"><span>Channel</span><span id="dc" class="pill">idle</span></div>
    <div class="kv"><span>Latency</span><span id="lat" class="pill">â€”</span></div>

    <h2>Session</h2>
    <div class="row"><button id="start" class="btn">Start Session</button></div>
    <div class="row" style="margin-top:8px">
      <input id="invite" class="mono" placeholder="Invite link appears here" readonly />
      <button id="copy" class="btn secondary">Copy</button>
      <button id="share" class="btn secondary">Share</button>
      <button id="open" class="btn secondary" title="Open worker tab" disabled>Open worker</button>
    </div>
    <div class="status" id="status">Create a session and send the link to workers.</div>

    <h2>Fractal Controls</h2>
    <div class="grid">
      <label>Resolution
        <select id="res">
          <option value="800x600">800 Ã— 600</option>
          <option value="1024x768" selected>1024 Ã— 768</option>
          <option value="1280x720">1280 Ã— 720</option>
          <option value="1600x900">1600 Ã— 900</option>
        </select>
        <small>Canvas size</small>
      </label>
      <label>Tile size
        <select id="tile">
          <option>64</option>
          <option selected>128</option>
          <option>256</option>
        </select>
        <small>Smaller = smoother, Larger = fewer messages</small>
      </label>
    </div>
    <div class="grid" style="margin-top:8px">
      <label>Max Iterations
        <input id="maxIter" type="number" value="300" min="50" max="2000"/>
        <small>Detail level</small>
      </label>
      <label>Palette
        <select id="palette">
          <option value="classic">Classic</option>
          <option value="fire">Fire</option>
          <option value="ice">Ice</option>
        </select>
        <small>Color mapping</small>
      </label>
    </div>

    <div class="grid" style="margin-top:8px">
      <label>Center Re <input id="cx" type="number" step="0.001" value="-0.75"/></label>
      <label>Center Im <input id="cy" type="number" step="0.001" value="0.0"/></label>
    </div>
    <div class="grid" style="margin-top:8px">
      <label>Scale
        <input id="scale" type="number" step="0.0001" value="0.0035"/>
        <small>Plane units per pixel (smaller = zoom in)</small>
      </label>
      <div class="row">
        <button id="preset1" class="btn secondary">Home</button>
        <button id="preset2" class="btn secondary">Seahorse</button>
        <button id="preset3" class="btn secondary">Elephant</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="render" class="btn" disabled>ðŸŽ¨ Render</button>
      <button id="cancel" class="btn secondary" disabled>Cancel</button>
    </div>

    <h2>Debug</h2>
    <textarea id="debug" rows="6" class="mono" readonly></textarea>
  </div>

  <div class="card">
    <h1>ðŸŒ€ Mandelbrot</h1>
    <canvas id="canvas" width="1024" height="768"></canvas>

    <h2>Activity</h2>
    <pre id="log" class="log mono"></pre>
  </div>
</div>

<script>
/*** CONFIG ***/
const SIGNAL_URL =
  (location.protocol === "https:" ? "wss://" : "ws://") +
  ((location.hostname && location.hostname !== "") ? location.hostname : "localhost") +
  ":" + ((location.port && location.port !== "") ? location.port : "8080");
// For sanity, allow manual override via ?signal=ws://host:port
(() => {
  const u = new URL(location.href);
  const override = u.searchParams.get("signal");
  if (override) window.SIGNAL_URL = override;
})();

const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

/*** DOM helpers ***/
const $ = s => document.querySelector(s);
function pill(el, text, cls){ el.textContent = text; el.className = "pill " + (cls||""); }
function setStatus(msg){ $("#status").textContent = msg; }
function setDebug(o){ $("#debug").value = JSON.stringify(o, null, 2); }
const logEl = $("#log");
function log(...a){ const ts=new Date().toLocaleTimeString(); logEl.textContent += `[${ts}] ${a.join(" ")}\n`; logEl.scrollTop = logEl.scrollHeight; }

/*** Signaling ***/
let sig = null, roomId = null, isCoord = false;
function sigSend(obj){ if(sig && sig.readyState === WebSocket.OPEN) sig.send(JSON.stringify(obj)); }
function openSignaling(id){
  return new Promise((res, rej) => {
    sig = new WebSocket(SIGNAL_URL);
    sig.onopen = () => { log("WS connected", SIGNAL_URL); sigSend({ type:"JOIN", room:id }); };
    sig.onmessage = async (e) => {
      let m; try { m = JSON.parse(e.data); } catch { return; }
      if (m.type === "JOINED") { log("Joined room", id); res(); return; }
      await onSignal(m);
    };
    sig.onerror = (err) => { log("WS error", err?.message||err); rej(err); };
    sig.onclose = () => { log("WS closed"); pill($("#pc"), "disconnected", "bad"); };
  });
}

/*** Global canvas dims ***/
let CANVAS_W = 1024, CANVAS_H = 768;

/*** WebRTC ***/
class Conn {
  constructor(role){ this.role=role; this.pc=null; this.dc=null; this._pingTimer=null; }
  async start(){
    this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 });
    this.pc.onconnectionstatechange = () => {
      const s=this.pc.connectionState; pill($("#pc"), s, s==="connected"?"ok":(["failed","closed"].includes(s)?"bad":"warn")); log("PC:", s);
    };
    this.pc.oniceconnectionstatechange = () => {
      const s=this.pc.iceConnectionState; pill($("#ice"), s, (s==="connected"||s==="completed")?"ok":(["failed","disconnected"].includes(s)?"bad":"warn"));
    };
    this.pc.onicecandidate = (e) => { if(e.candidate) sigSend({ type:"ICE", room:roomId, candidate:e.candidate }); };
    if (this.role === "coordinator") { this.dc = this.pc.createDataChannel("mesh",{ordered:true,maxRetransmits:3}); this.wireDC(this.dc); }
    else { this.pc.ondatachannel = (e) => { this.dc = e.channel; this.wireDC(this.dc); }; }
  }
  wireDC(dc){
    dc.onopen = () => {
      pill($("#dc"), "open", "ok");
      if (this.role === "coordinator") $("#render").disabled = false;
      $("#cancel").disabled = false;
      setStatus(this.role === "coordinator" ? "Connected. Ready to render." : "Connected. Waiting for tasksâ€¦");
      log("DC open");
      stopOfferRetries();
      this._pingTimer = setInterval(()=>this.ping(), 5000);
    };
    dc.onclose = () => { pill($("#dc"), "closed", "bad"); $("#render").disabled = true; $("#cancel").disabled = true; log("DC closed"); clearInterval(this._pingTimer); };
    dc.onerror = (e) => { pill($("#dc"), "error", "bad"); log("DC error:", e?.message||e); };
    dc.onmessage = (ev) => this.onMsg(ev);
  }
  send(obj){ if (this.dc?.readyState==="open") this.dc.send(JSON.stringify(obj)); }
  ping(){ this.send({ type:"PING", t: Date.now() }); }
  async onMsg(ev){
    const m = JSON.parse(ev.data);
    if (m.type === "PING") this.send({ type:"PONG", t:m.t });
    else if (m.type === "PONG") { const rtt = Date.now()-m.t; pill($("#lat"), `${rtt}ms`, rtt<60?"ok":"warn"); }
    else if (m.type === "TASK" && m.kind === "FRACTAL_TILE") {
      const { w,h,x0,y0,cx,cy,scale,maxIter,palette } = m.params;
      const rgba = renderMandelbrotTile(w,h,x0,y0,cx,cy,scale,maxIter,palette);
      const b64 = bytesToBase64(rgba);
      this.send({ type:"RESULT", id:m.id, kind:"FRACTAL_TILE", tile:{x0,y0,w,h}, base64:b64, ms:rgba.timeMs });
      log(`tile done (${w}Ã—${h}) @(${x0},${y0}) ${rgba.timeMs}ms`);
    } else if (m.type === "RESULT" && isCoord && m.kind === "FRACTAL_TILE") {
      drawTile(m);
    }
  }
  async makeOffer(){ const offer=await this.pc.createOffer(); await this.pc.setLocalDescription(offer); sigSend({ type:"OFFER", room:roomId, sdp:offer }); log("Offer sent"); }
  async acceptOffer(offer){ await this.pc.setRemoteDescription(offer); const ans=await this.pc.createAnswer(); await this.pc.setLocalDescription(ans); sigSend({ type:"ANSWER", room:roomId, sdp:ans }); log("Answer sent"); }
  async acceptAnswer(answer){ await this.pc.setRemoteDescription(answer); log("Answer accepted"); }
}
let conn=null;

/*** Offer retries ***/
let offerRetryTimer=null;
function startOfferRetries(){
  stopOfferRetries();
  offerRetryTimer = setInterval(async ()=>{
    if (!isCoord || !conn?.pc) return;
    if (conn.pc.connectionState === "connected" || conn.pc.remoteDescription?.type === "answer") { stopOfferRetries(); return; }
    try { await conn.makeOffer(); log("Offer retry"); } catch {}
  }, 3000);
}
function stopOfferRetries(){ if (offerRetryTimer){ clearInterval(offerRetryTimer); offerRetryTimer=null; } }

/*** Signaling messages ***/
async function onSignal(m){
  if (!conn) return;
  if (m.type === "PEER_JOINED" && isCoord) { log("Peer joined â†’ send offer"); try { await conn.makeOffer(); } catch {} return; }
  if (m.type === "OFFER" && !isCoord) { log("Got OFFER"); await conn.acceptOffer(m.sdp); }
  else if (m.type === "ANSWER" && isCoord) { log("Got ANSWER"); await conn.acceptAnswer(m.sdp); stopOfferRetries(); }
  else if (m.type === "ICE") { try { await conn.pc.addIceCandidate(m.candidate); } catch(e) { /* ignore benign */ } }
}

/*** Fractal core ***/
function renderMandelbrotTile(w,h,x0,y0,cx,cy,scale,maxIter,paletteName){
  const bytes = new Uint8ClampedArray(w*h*4);
  const t0 = performance.now();
  const colorClassic = t => [Math.floor(9*(1-t)*t*t*t*255), Math.floor(15*(1-t)*(1-t)*t*t*255), Math.floor(8.5*(1-t)*(1-t)*(1-t)*t*255)];
  const colorFire = t => [Math.floor(255*t), Math.floor(120*Math.sqrt(t)), Math.floor(40*t*t)];
  const colorIce = t => [Math.floor(40*t*t), Math.floor(140*t), Math.floor(255*Math.sqrt(t))];
  const pick = paletteName==="fire"?colorFire:paletteName==="ice"?colorIce:colorClassic;

  for(let py=0; py<h; py++){
    for(let px=0; px<w; px++){
      const X = cx + (x0 + px - CANVAS_W/2) * scale;
      const Y = cy + (y0 + py - CANVAS_H/2) * scale;
      let zr=0, zi=0, iter=0;
      while (zr*zr + zi*zi <= 4 && iter < maxIter){ const zr2 = zr*zr - zi*zi + X; zi = 2*zr*zi + Y; zr = zr2; iter++; }
      let r,g,b;
      if (iter===maxIter){ r=g=b=0; }
      else { const zn=Math.hypot(zr,zi); const nu=Math.log2(Math.log(zn)); const sm=Math.min(1, Math.max(0,(iter+1-nu)/maxIter)); [r,g,b]=pick(sm); }
      const i=(py*w+px)*4; bytes[i]=r; bytes[i+1]=g; bytes[i+2]=b; bytes[i+3]=255;
    }
  }
  bytes.timeMs = Math.round(performance.now() - t0);
  return bytes;
}

/*** Base64 helpers ***/
function bytesToBase64(bytes){
  let binary=""; const CHUNK=0x8000;
  for(let i=0;i<bytes.length;i+=CHUNK){ binary += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i+CHUNK, bytes.length))); }
  return btoa(binary);
}
function base64ToBytes(b64){ const bin=atob(b64); const len=bin.length; const out=new Uint8ClampedArray(len); for(let i=0;i<len;i++) out[i]=bin.charCodeAt(i); return out; }

/*** Canvas + tiling ***/
const canvas = $("#canvas"); const ctx = canvas.getContext("2d");
let renderState = { inProgress:false, tilesTotal:0, tilesDone:0, currentJob:null, startTime:0 };
function resizeCanvas(w,h){ canvas.width=w; canvas.height=h; CANVAS_W=w; CANVAS_H=h; ctx.fillStyle="#0c0c14"; ctx.fillRect(0,0,w,h); }
function planTiles(tile){ const a=[]; for(let y=0;y<CANVAS_H;y+=tile){ for(let x=0;x<CANVAS_W;x+=tile){ a.push({x0:x,y0:y,w:Math.min(tile,CANVAS_W-x),h:Math.min(tile,CANVAS_H-y)}); } } return a; }
function drawTile(msg){
  const {x0,y0,w,h}=msg.tile; const bytes=base64ToBytes(msg.base64); const img=new ImageData(bytes,w,h); ctx.putImageData(img,x0,y0);
  renderState.tilesDone++; const pct=Math.round(100*renderState.tilesDone/renderState.tilesTotal); const elapsed=((Date.now()-renderState.startTime)/1000).toFixed(1);
  log(`Tile ${renderState.tilesDone}/${renderState.tilesTotal} (${pct}%) - ${elapsed}s`);
  setStatus(`Rendering: ${pct}%`);
  if (renderState.tilesDone>=renderState.tilesTotal){ renderState.inProgress=false; $("#render").disabled=false; $("#cancel").disabled=true; const total=((Date.now()-renderState.startTime)/1000).toFixed(1); setStatus(`Render complete âœ“ (${total}s)`); }
}

/*** UI ***/
$("#start").onclick = async () => {
  try {
    $("#start").disabled = true;
    isCoord = true;
    roomId = (crypto.randomUUID?.() || Math.random().toString(36).slice(2,10)).replace(/-/g,'');
    setStatus("Creating roomâ€¦");
    await openSignaling(roomId);
    const url = location.origin + location.pathname + "#room=" + roomId;
    $("#invite").value = url;
    $("#copy").onclick = () => navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));
    $("#share").onclick = () => navigator.share ? navigator.share({title:"NyxMesh Session",text:"Join my session",url}) : navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));
    $("#open").onclick = () => window.open(url, "_blank", "noopener,noreferrer");
    $("#open").disabled = false;

    conn = new Conn("coordinator");
    await conn.start();
    await conn.makeOffer();
    startOfferRetries();
    setDebug({ SIGNAL_URL, roomId, role:"coordinator", invite:url });
    setStatus("Room created. Waiting for worker to joinâ€¦");
  } catch (e) { setStatus("Failed to start: " + e.message); $("#start").disabled=false; }
};

$("#render").onclick = () => {
  if (!conn?.dc || conn.dc.readyState!=="open") { setStatus("Not connected to worker"); return; }
  const [w,h] = $("#res").value.split("x").map(Number);
  const tileSize = parseInt($("#tile").value,10);
  const maxIter = parseInt($("#maxIter").value,10);
  const palette = $("#palette").value;
  const cx = parseFloat($("#cx").value);
  const cy = parseFloat($("#cy").value);
  const scale = parseFloat($("#scale").value);
  resizeCanvas(w,h);
  const tiles = planTiles(tileSize);
  renderState = { inProgress:true, tilesTotal:tiles.length, tilesDone:0, currentJob:Math.random().toString(36).slice(2,10), startTime:Date.now() };
  setStatus(`Starting render: ${w}Ã—${h}, ${tiles.length} tilesâ€¦`);
  $("#render").disabled=true; $("#cancel").disabled=true; // (no cancel logic hooked to worker in this version)
  tiles.forEach((t,i) => {
    const id = `tile_${renderState.currentJob}_${i}`;
    const params = { x0:t.x0, y0:t.y0, w:t.w, h:t.h, cx, cy, scale, maxIter, palette };
    conn.send({ type:"TASK", id, kind:"FRACTAL_TILE", params });
  });
};

// Presets
$("#preset1").onclick = () => { $("#cx").value=-0.75; $("#cy").value=0.0; $("#scale").value=0.0035; };
$("#preset2").onclick = () => { $("#cx").value=-0.7435; $("#cy").value=0.1314; $("#scale").value=0.0007; };
$("#preset3").onclick = () => { $("#cx").value=0.285; $("#cy").value=0.01; $("#scale").value=0.0012; };

/*** Auto-join as worker ***/
(async ()=>{
  const p = new URLSearchParams(location.hash.slice(1));
  const rid = p.get("room"); if (!rid) return;
  roomId = rid; isCoord = false; setStatus("Joining room as workerâ€¦"); log("Join as worker:", roomId);
  try { await openSignaling(roomId); conn = new Conn("worker"); await conn.start(); setStatus("Worker ready. Waiting for tasksâ€¦"); setDebug({ SIGNAL_URL, roomId, role:"worker" }); $("#start").disabled=true; $("#render").disabled=true; }
  catch(e){ setStatus("Join failed: " + e.message); }
})();
</script>
</body>
</html>
