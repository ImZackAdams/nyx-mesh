<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NyxMesh â€¢ 1-Click P2P (Tiny WS Relay)</title>
<style>
  :root{--bg:#0b0b0f;--panel:#16161d;--ink:#eaeaf2;--muted:#a7a7b3;--accent:#9b5cff;--accent-hover:#b47d7ff0;}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:radial-gradient(1200px 600px at 10% 0%,#141421 0%,var(--bg) 60%);color:var(--ink);display:flex;justify-content:center;padding:18px}
  .wrap{width:100%;max-width:980px;display:grid;grid-template-columns:320px 1fr;gap:14px}
  .card{background:var(--panel);border:1px solid #222231;border-radius:14px;padding:14px}
  h1{margin:0 0 8px;font-size:18px} h2{margin:0 0 10px;font-size:15px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);color:#0b0b0f;border:0;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;transition:.2s}
  .btn:hover{background:var(--accent-hover);transform:translateY(-1px)}
  .btn.secondary{background:#2a2a38;color:var(--ink);border:1px solid #333349}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  input,select,textarea{width:100%;background:#0f0f16;color:#0ef;border:1px solid #282838;border-radius:8px;padding:10px}
  .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #2a2a3a;padding:4px 0}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#24243a;color:var(--ink);font-size:12px}
  .ok{background:#1d3d23;color:#7dff8b}.warn{background:#3d3d1d;color:#ffe57d}.bad{background:#3d1d1d;color:#ff7d7d}
  .log{height:220px;overflow:auto;background:#0e0e15;border:1px solid #242436;border-radius:8px;padding:8px}
  .status{margin-top:10px;padding:8px;border-radius:8px;background:#1a1a24;border:1px solid #2a2a3a;font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>ðŸš€ NyxMesh (WS Relay)</h1>
    <div class="kv"><span>Connection</span><span id="pc" class="pill">idle</span></div>
    <div class="kv"><span>ICE</span><span id="ice" class="pill">idle</span></div>
    <div class="kv"><span>Channel</span><span id="dc" class="pill">idle</span></div>
    <div class="kv"><span>Latency</span><span id="lat" class="pill">â€”</span></div>

    <h2>Session</h2>
    <div class="row"><button id="start" class="btn">Start Session</button></div>
    <div class="row" style="margin-top:8px">
      <input id="invite" class="mono" placeholder="Invite link appears here" readonly />
      <button id="copy" class="btn secondary">Copy</button>
      <button id="share" class="btn secondary">Share</button>
    </div>
    <div class="status" id="status">Create a session and send the link to workers.</div>

    <h2>Debug</h2>
    <textarea id="debug" rows="6" class="mono" readonly></textarea>
  </div>

  <div class="card">
    <h1>âš¡ Compute</h1>
    <div class="row">
      <label class="mono">Matrix size:
        <select id="size">
          <option value="128">128</option>
          <option value="256" selected>256</option>
          <option value="512">512</option>
          <option value="1024">1024</option>
        </select>
      </label>
      <button id="run" class="btn" disabled>Run Task</button>
    </div>

    <h2>Activity</h2>
    <pre id="log" class="log mono"></pre>
  </div>
</div>

<script>
/*** CONFIG ***/
// If this page is file:// or http:// use ws://localhost:8080 by default.
// If the page is https:// you must use a wss:// relay.
const SIGNAL_URL = (location.protocol === "https:" ? "wss://" : "ws://") +
                   (location.hostname || "localhost") +
                   ":" + (location.port || "8080");

const ICE_SERVERS = [
  { urls: "stun:stun.l.google.com:19302" }
  // Add TURN here for tough NATs:
  // { urls: "turn:turn.yourdomain.com:3478", username: "nyx", credential: "meshpass" }
];

/*** DOM helpers ***/
const $ = s => document.querySelector(s);
function pill(el, text, cls){ el.textContent = text; el.className = "pill " + (cls||""); }
function setStatus(msg){ $("#status").textContent = msg; }
function setDebug(o){ $("#debug").value = JSON.stringify(o, null, 2); }
const logEl = $("#log");
function log(...a){ const ts=new Date().toLocaleTimeString(); logEl.textContent += `[${ts}] ${a.join(" ")}\n`; logEl.scrollTop = logEl.scrollHeight; }

/*** Signaling ***/
let sig, roomId, isCoord=false;
function sigSend(obj){ if(sig && sig.readyState===1) sig.send(JSON.stringify(obj)); }
function openSignaling(id){
  return new Promise((res, rej)=>{
    sig = new WebSocket(SIGNAL_URL);
    sig.onopen = () => sigSend({ type:"JOIN", room:id });
    sig.onmessage = async (e) => {
      let m; try { m = JSON.parse(e.data); } catch { return; }
      if (m.type === "JOINED") { res(); return; }
      await onSignal(m);
    };
    sig.onerror = rej;
  });
}

/*** WebRTC ***/
class Conn {
  constructor(role){ this.role=role; this.pc=null; this.dc=null; this.lastPing=0; }
  async start(){
    this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 });
    this.pc.onconnectionstatechange = () => {
      const s=this.pc.connectionState;
      pill($("#pc"), s, s==="connected"?"ok":(["failed","closed"].includes(s)?"bad":"warn"));
      log("pc:", s);
    };
    this.pc.oniceconnectionstatechange = () => {
      const s=this.pc.iceConnectionState;
      pill($("#ice"), s, (s==="connected"||s==="completed")?"ok":(["failed","disconnected"].includes(s)?"bad":"warn"));
    };
    this.pc.onicecandidate = (e) => { if(e.candidate) sigSend({ type:"ICE", room:roomId, candidate:e.candidate }); };
    if (this.role === "coordinator") {
      this.dc = this.pc.createDataChannel("mesh",{ordered:true,maxRetransmits:3});
      this.wireDC(this.dc);
    } else {
      this.pc.ondatachannel = (e) => { this.dc = e.channel; this.wireDC(this.dc); };
    }
  }
  wireDC(dc){
    dc.onopen = () => {
      pill($("#dc"), "open", "ok");
      $("#run").disabled = (this.role!=="coordinator");
      setStatus("Connected.");
      log("dc: open");
      stopOfferRetries();                 // <- stop resending offers once connected
      this.ping();
      this._pingTimer = setInterval(()=>this.ping(), 5000);
    };
    dc.onclose = () => {
      pill($("#dc"), "closed", "bad");
      $("#run").disabled = true;
      log("dc: closed");
      if (this._pingTimer) clearInterval(this._pingTimer);
    };
    dc.onerror = (e) => { pill($("#dc"), "error", "bad"); log("dc error:", e?.message||e); };
    dc.onmessage = (ev) => this.onMsg(ev);
  }
  send(obj){ if (this.dc && this.dc.readyState==="open") this.dc.send(JSON.stringify(obj)); }
  ping(){ if (this.dc?.readyState==="open") this.send({ type:"PING", t: Date.now() }); }
  async onMsg(ev){
    try{
      const m = JSON.parse(ev.data);
      if (m.type === "PING") this.send({ type:"PONG", t:m.t });
      else if (m.type === "PONG") { const rtt = Date.now()-m.t; pill($("#lat"), `${rtt}ms`, rtt<60?"ok":"warn"); }
      else if (m.type === "TASK") {
        const n = m.n || 256;
        const comp = doMatmul(n);
        const hash = await sha256Hex(new Uint8Array(comp.result.buffer));
        this.send({ type:"RESULT", id:m.id, ms:Math.round(comp.time), n, gflops:(comp.ops/(comp.time*1e6)).toFixed(3), hash });
      } else if (m.type === "RESULT") {
        log(`result: ${m.gflops} GFLOPS, ${m.ms}ms (n=${m.n})`);
      }
    } catch (e) { log("onmessage err:", e?.message||e); }
  }
  async makeOffer(){
    const off=await this.pc.createOffer();
    await this.pc.setLocalDescription(off);
    sigSend({ type:"OFFER", room:roomId, sdp:off });
  }
  async acceptOffer(offer){
    await this.pc.setRemoteDescription(offer);
    const ans=await this.pc.createAnswer();
    await this.pc.setLocalDescription(ans);
    sigSend({ type:"ANSWER", room:roomId, sdp:ans });
  }
  async acceptAnswer(answer){ await this.pc.setRemoteDescription(answer); }
}
let conn;

/*** Offer retry logic (handles late joiners) ***/
let offerRetryTimer = null;
function startOfferRetries(){
  stopOfferRetries();
  offerRetryTimer = setInterval(async ()=>{
    if (!isCoord) return;
    if (!conn?.pc) return;
    // Stop if we already have an answer or are connected
    if (conn.pc.connectionState === "connected" || conn.pc.remoteDescription?.type === "answer") {
      stopOfferRetries();
      return;
    }
    try {
      await conn.makeOffer();
      console.log("OFFER re-sent");
    } catch {}
  }, 3000);
}
function stopOfferRetries(){
  if (offerRetryTimer) { clearInterval(offerRetryTimer); offerRetryTimer = null; }
}

/*** Handle incoming signals ***/
async function onSignal(m){
  if (!conn) return;

  if (m.type === "PEER_JOINED" && isCoord) {
    // A worker joined after we created the room â€” send a fresh offer.
    try { await conn.makeOffer(); } catch {}
    return;
  }

  if (m.type === "OFFER" && !isCoord) {
    log("got OFFER");
    await conn.acceptOffer(m.sdp);
  } else if (m.type === "ANSWER" && isCoord) {
    log("got ANSWER");
    await conn.acceptAnswer(m.sdp);
    stopOfferRetries(); // we have an answer
  } else if (m.type === "ICE") {
    try { await conn.pc.addIceCandidate(m.candidate); } catch {}
  }
}

/*** Single task: matmul ***/
function doMatmul(n){
  const A=new Float32Array(n*n), B=new Float32Array(n*n), C=new Float32Array(n*n);
  for(let i=0;i<n*n;i++){ A[i]=Math.random()*2-1; B[i]=Math.random()*2-1; }
  const t0=performance.now();
  for(let i=0;i<n;i++){ for(let k=0;k<n;k++){ const aik=A[i*n+k]; for(let j=0;j<n;j++){ C[i*n+j]+=aik*B[k*n+j]; } } }
  const t1=performance.now();
  return { result:C, time:t1-t0, ops:2*Math.pow(n,3) };
}
async function sha256Hex(bytes){ const buf=await crypto.subtle.digest("SHA-256", bytes); return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join(""); }

/*** UI ***/
$("#start").onclick = async () => {
  try {
    isCoord = true;
    roomId = (crypto.randomUUID?.() ?? Math.random().toString(36)).slice(0,8).replace(/-/g,'');
    await openSignaling(roomId);
    setStatus("Room created. Sending offer when worker joinsâ€¦");
    const url = location.origin + location.pathname + "#room=" + roomId;
    $("#invite").value = url;
    $("#share").onclick = () => navigator.share ? navigator.share({ title:"NyxMesh", text:"Join my session", url }) : navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));
    $("#copy").onclick = () => navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));

    conn = new Conn("coordinator");
    await conn.start();
    await conn.makeOffer();
    startOfferRetries(); // <-- keep offering until a worker answers
    setDebug({ SIGNAL_URL, roomId, role:"coordinator" });
  } catch (e) {
    setStatus("Failed to start session."); console.error(e);
  }
};

$("#run").onclick = () => {
  if (!conn?.dc || conn.dc.readyState!=="open") return;
  const n = parseInt($("#size").value, 10);
  const id = "job_" + Math.random().toString(36).slice(2,8);
  log(`task â†’ matmul n=${n}`);
  conn.send({ type:"TASK", id, n });
};

/*** Auto-join as worker via #room=ID ***/
(async ()=>{
  const p = new URLSearchParams(location.hash.slice(1));
  const rid = p.get("room");
  if (!rid) return;
  roomId = rid; isCoord = false; setStatus("Joining roomâ€¦");
  try {
    await openSignaling(roomId);
    conn = new Conn("worker");
    await conn.start();
    setStatus("Waiting for offerâ€¦");
    setDebug({ SIGNAL_URL, roomId, role:"worker" });
  } catch (e) {
    setStatus("Join failed."); console.error(e);
  }
})();
</script>
</body>
</html>
