<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NyxMesh ‚Ä¢ P2P GA Optimizer (Distributed TSP)</title>
<style>
  :root{--bg:#0b0b0f;--panel:#16161d;--ink:#eaeaf2;--muted:#a7a7b3;--accent:#9b5cff;--accent-hover:#b47dff;--good:#7dff8b;--warn:#ffe57d;--bad:#ff7d7d}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:radial-gradient(1200px 600px at 10% 0%,#141421 0%,var(--bg) 60%);color:var(--ink);display:flex;justify-content:center;padding:18px}
  .wrap{width:100%;max-width:1200px;display:grid;grid-template-columns:380px 1fr;gap:14px}
  .card{background:var(--panel);border:1px solid #222231;border-radius:14px;padding:14px}
  h1{margin:0 0 8px;font-size:18px} h2{margin:12px 0 10px;font-size:15px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);color:#0b0b0f;border:0;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;transition:.2s}
  .btn:hover{background:var(--accent-hover);transform:translateY(-1px)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.secondary{background:#2a2a38;color:var(--ink);border:1px solid #333349}
  .btn.ghost{background:transparent;border:1px dashed #333349;color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  input,select{width:100%;background:#0f0f16;color:#0ef;border:1px solid #282838;border-radius:8px;padding:10px}
  .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #2a2a3a;padding:4px 0}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#24243a;color:var(--ink);font-size:12px}
  .ok{background:#1d3d23;color:var(--good)}.warn{background:#3d3d1d;color:var(--warn)}.bad{background:#3d1d1d;color:var(--bad)}
  .log{height:200px;overflow:auto;background:#0e0e15;border:1px solid #242436;border-radius:8px;padding:8px}
  .status{margin-top:10px;padding:8px;border-radius:8px;background:#1a1a24;border:1px solid #2a2a3a;font-size:13px}
  canvas{width:100%;height:auto;background:#0c0c14;border:1px solid #242436;border-radius:10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .workers{margin-top:6px;display:flex;flex-direction:column;gap:6px}
  .worker{display:grid;grid-template-columns:1fr auto auto auto;gap:8px;align-items:center;padding:8px;border:1px solid #2b2b3a;border-radius:10px;background:#12121a}
  .muted{color:var(--muted)}
  @media (max-width: 860px) {.wrap{grid-template-columns:1fr}.card:first-child{order:2}.card:last-child{order:1}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>üß¨ NyxMesh GA (Distributed TSP)</h1>
    <div class="kv"><span>Signaling</span><span id="sigState" class="pill">idle</span></div>
    <div class="kv"><span>Workers</span><span id="workerCount" class="pill">0</span></div>
    <div class="kv"><span>Epoch</span><span id="epoch" class="pill">0</span></div>

    <h2>Session</h2>
    <div class="row"><button id="start" class="btn">Start Session</button></div>
    <div class="row" style="margin-top:8px">
      <input id="invite" class="mono" placeholder="Invite link appears here" readonly />
      <button id="copy" class="btn secondary" title="Copy link">Copy</button>
      <button id="share" class="btn secondary" title="Share link">Share</button>
      <button id="qr" class="btn secondary" title="Show QR">QR</button>
      <button id="open" class="btn secondary" title="Open worker tab" disabled>Open worker</button>
    </div>
    <div class="status" id="status">Create a session and send the link to workers.</div>

    <h2>GA Controls</h2>
    <div class="grid">
      <label>Cities
        <input id="cities" type="number" value="40" min="8" max="120"/>
        <small>Problem size</small>
      </label>
      <label>Pop / Worker
        <input id="pop" type="number" value="150" min="20" step="10"/>
        <small>Local population</small>
      </label>
    </div>
    <div class="grid" style="margin-top:8px">
      <label>Gen / Epoch
        <input id="gens" type="number" value="80" min="10" step="10"/>
        <small>Worker generations per epoch</small>
      </label>
      <label>Mutation %
        <input id="mut" type="number" value="8" min="0" max="50"/>
        <small>Swap mutate chance</small>
      </label>
    </div>
    <div class="grid" style="margin-top:8px">
      <label>Elites / Worker
        <input id="elites" type="number" value="5" min="1" max="20"/>
        <small>Migrate these up</small>
      </label>
      <label>Reset Cities
        <select id="reset">
          <option value="no" selected>No</option>
          <option value="yes">Yes</option>
        </select>
        <small>Regenerate instances</small>
      </label>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="run" class="btn" disabled>‚ñ∂Ô∏è Start</button>
      <button id="stop" class="btn secondary" disabled>Stop</button>
      <button id="snapshot" class="btn ghost" disabled>Snapshot</button>
    </div>

    <h2>Workers</h2>
    <div id="workers" class="workers"></div>

    <h2>Debug</h2>
    <textarea id="debug" rows="5" class="mono" readonly></textarea>
  </div>

  <div class="card">
    <h1>üó∫Ô∏è Best Tour <span id="bestLen" class="pill">‚Äî</span></h1>
    <canvas id="canvas" width="1024" height="768"></canvas>
    <h2>Activity</h2>
    <pre id="log" class="log mono"></pre>
  </div>
</div>

<script>
/***** CONFIG *****/
const DEFAULT_SIGNAL_URL = (location.protocol === "https:" ? "wss://" : "ws://")
  + ((location.hostname && location.hostname !== "") ? location.hostname : "localhost")
  + ":" + ((location.port && location.port !== "") ? location.port : "8080");
let SIGNAL_URL = DEFAULT_SIGNAL_URL;
(() => { const u = new URL(location.href); const override = u.searchParams.get("signal"); if (override) SIGNAL_URL = override; })();
const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];
const MAX_INFLIGHT_PER_WORKER = 2;
const EPOCH_TIMEOUT_MS = 15000;

/***** DOM helpers *****/
const $ = s => document.querySelector(s);
function pill(el, text, cls){ el.textContent = text; el.className = "pill " + (cls||""); }
function setStatus(msg){ $("#status").textContent = msg; }
function setDebug(o){ $("#debug").value = JSON.stringify(o, null, 2); }
const logEl = $("#log");
function log(...a){ const ts=new Date().toLocaleTimeString(); logEl.textContent += `[${ts}] ${a.join(" ")}\n`; logEl.scrollTop = logEl.scrollHeight; }

/***** Global state *****/
const peerId = (crypto.randomUUID?.() || Math.random().toString(36).slice(2,10)).replace(/-/g,'');
let roomId = null, isCoord = false;
let sig = null; // WebSocket

const canvas = $("#canvas"); const ctx = canvas.getContext("2d");
let CANVAS_W = canvas.width, CANVAS_H = canvas.height;

const workers = new Map(); // id -> Peer
function refreshWorkersUI(){
  $("#workerCount").textContent = String(workers.size);
  const host = $("#workers"); host.innerHTML = "";
  for (const p of workers.values()){
    const el = document.createElement('div'); el.className = 'worker'; el.id = `w-${p.id}`;
    el.innerHTML = `
      <div class="mono">${p.id.slice(0,8)} <span class="muted">${p.wsOnly? 'ws-only' : p.state}</span></div>
      <div class="pill ${p.rtt<80?'ok':p.rtt<200?'warn':'bad'}">${p.rtt? p.rtt+'ms':'‚Äî'}</div>
      <div class="pill">inflight ${p.inflight}</div>
      <div class="pill">epochs ${p.epochs||0}</div>`;
    host.appendChild(el);
  }
}

/***** TSP instance + best tracking (coordinator) *****/
let CITY = [];      // [{x,y},...]
let BEST = { route:null, len:Infinity };
let running=false, epochNo=0;
function genCities(n){
  CITY = Array.from({length:n}, ()=>({x: Math.random()*CANVAS_W*.9 + CANVAS_W*.05, y: Math.random()*CANVAS_H*.8 + CANVAS_H*.1}));
}
function draw(){
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
  // cities
  ctx.fillStyle="#eaeaf2"; for (const c of CITY){ ctx.beginPath(); ctx.arc(c.x,c.y,3,0,Math.PI*2); ctx.fill(); }
  // best path
  if (BEST.route){
    ctx.strokeStyle="#9b5cff"; ctx.lineWidth=2; ctx.beginPath();
    let i0 = BEST.route[0]; ctx.moveTo(CITY[i0].x, CITY[i0].y);
    for (let i=1;i<BEST.route.length;i++){ const ci = CITY[BEST.route[i]]; ctx.lineTo(ci.x,ci.y); }
    ctx.lineTo(CITY[i0].x, CITY[i0].y);
    ctx.stroke();
  }
  $("#bestLen").textContent = (BEST.len<Infinity? BEST.len.toFixed(1) : "‚Äî");
}

/***** Signaling *****/
function sigSend(obj){ if(sig && sig.readyState === WebSocket.OPEN) sig.send(JSON.stringify(obj)); }
function openSignaling(id){
  return new Promise((res) => {
    sig = new WebSocket(SIGNAL_URL);
    sig.onopen = () => {
      pill($("#sigState"), "open", "ok");
      log("WS connected", SIGNAL_URL);
      sigSend({ type:"JOIN", room:id, peer:peerId, role:isCoord? 'coordinator':'worker' });
      sigSend({ type:"HELLO", room:id, from:peerId, role:isCoord? 'coordinator':'worker' });
      res();
    };
    sig.onmessage = async (e) => { let m; try { m = JSON.parse(e.data); } catch { return; } await onSignal(m); };
    sig.onerror = (err) => { log("WS error", err?.message||err); pill($("#sigState"), "error", "bad"); };
    sig.onclose = () => { pill($("#sigState"), "closed", "bad"); };
  });
}

async function onSignal(m){
  if (m.room && m.room !== roomId) return;

  // WS fallback for worker epochs
  if (!isCoord && m.type==='TASK_WS' && m.to===peerId && m.kind==='GA_EPOCH'){
    const out = runEpochLocal(m.params);
    sigSend({ type:'RESULT_WS', room:roomId, from:peerId, id:m.id, kind:'GA_EPOCH', result: out });
    return;
  }

  if (isCoord){
    if (m.type==='HELLO' && m.from && m.from!==peerId){ ensurePeer(m.from).maybeConnect(); return; }
    if (m.type==='PEER_JOINED' && m.peer){ ensurePeer(m.peer).maybeConnect(); return; }
    if (m.type==='ANSWER' && m.from){ const p = workers.get(m.from); if (p) await p.acceptAnswer(m.sdp); return; }
    if (m.type==='ICE' && m.from){ const p = workers.get(m.from); if (p) try{ await p.pc?.addIceCandidate(m.candidate); }catch{} return; }
    if (m.type==='RESULT_WS' && m.from && m.kind==='GA_EPOCH'){ handleEpochResult(m.from, m.id, m.result); return; }
  } else {
    if (m.type==='OFFER' && (m.to===peerId || !m.to)){
      if (!workerConn) { workerConn = new WorkerConn(); await workerConn.start(); }
      await workerConn.acceptOffer(m.sdp, m.from);
      return;
    }
    if (m.type==='ICE' && (m.to===peerId || !m.to)){
      try { await workerConn?.pc?.addIceCandidate(m.candidate); } catch {}
      return;
    }
  }
}

/***** Peer wrapper (coordinator side) *****/
class Peer{
  constructor(id){
    this.id=id; this.pc=null; this.ctrl=null; this.state='idle';
    this.rtt=0; this._rttEMA=null; this._pingTimer=null; this.inflight=0; this.epochs=0;
    this.wsOnly=false; this.offerRetry=null; this._everConnected=false;
  }
  async maybeConnect(){
    if (this.pc || this.wsOnly) return;
    this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 });
    this.pc.onconnectionstatechange = () => {
      const s=this.pc.connectionState; this.state=s; refreshWorkersUI();
      if (s==='connected'){ clearInterval(this.offerRetry); enableRunIfReady(); }
      if (s==='failed' || s==='closed' || s==='disconnected'){
        if (!this._everConnected){ this.wsOnly=true; refreshWorkersUI(); enableRunIfReady(); }
      }
    };
    this.pc.onicecandidate = (e)=>{ if(e.candidate) sigSend({ type:'ICE', room:roomId, to:this.id, from:peerId, candidate:e.candidate }); };

    this.ctrl = this.pc.createDataChannel('ctrl',{ordered:true});
    this.ctrl.onopen = ()=>{ this.state='dc-open'; this._startPings(); refreshWorkersUI(); enableRunIfReady(); };
    this.ctrl.onmessage = (ev)=>{
      const m = JSON.parse(ev.data);
      if (m.type==='PONG'){ const rtt=Date.now()-m.t; this._rttEMA=this._rttEMA==null?rtt:(0.8*this._rttEMA+0.2*rtt); this.rtt=Math.round(this._rttEMA); refreshWorkersUI(); return; }
      if (m.type==='RESULT' && m.kind==='GA_EPOCH'){ this.inflight=Math.max(0,this.inflight-1); this.epochs++; refreshWorkersUI(); handleEpochResult(this.id, m.id, m.result); return; }
    };

    const offer = await this.pc.createOffer(); await this.pc.setLocalDescription(offer);
    sigSend({ type:'OFFER', room:roomId, to:this.id, from:peerId, sdp:offer });
    this.offerRetry = setInterval(async()=>{
      if (this.pc?.connectionState==='connected' || this.pc?.remoteDescription?.type==='answer'){ clearInterval(this.offerRetry); return; }
      try{ const o=await this.pc.createOffer(); await this.pc.setLocalDescription(o); sigSend({ type:'OFFER', room:roomId, to:this.id, from:peerId, sdp:o }); }catch{}
    }, 3000);
  }
  async acceptAnswer(ans){ await this.pc.setRemoteDescription(ans); this._everConnected=true; }
  _startPings(){ this._pingTimer = setInterval(()=>{ this.ctrl?.send(JSON.stringify({type:'PING', t:Date.now()})); }, 4000); }
  canSend(){ return this.wsOnly || (this.ctrl?.readyState==='open' && this.inflight<MAX_INFLIGHT_PER_WORKER); }
  sendEpoch(job){
    if (this.wsOnly){ sigSend({ type:'TASK_WS', room:roomId, to:this.id, from:peerId, id:job.id, kind:'GA_EPOCH', params:job.params }); this.inflight++; return true; }
    try{ this.ctrl.send(JSON.stringify({ type:'TASK', id:job.id, kind:'GA_EPOCH', params:job.params })); this.inflight++; return true; }catch{ return false; }
  }
}
function ensurePeer(id){ let p = workers.get(id); if (!p){ p=new Peer(id); workers.set(id,p); refreshWorkersUI(); enableRunIfReady(); } return p; }

/***** Worker connection (worker side) *****/
let workerConn = null;
class WorkerConn{
  constructor(){ this.pc=null; this.ctrl=null; }
  async start(){
    this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 });
    this.pc.ondatachannel = (e)=>{ if (e.channel.label==='ctrl'){ this.ctrl=e.channel; this.wireCtrl(); } };
    this.pc.onicecandidate = (e)=>{ if(e.candidate) sigSend({ type:'ICE', room:roomId, to:'coordinator', from:peerId, candidate:e.candidate }); };
  }
  wireCtrl(){
    this.ctrl.onopen = ()=>{ setStatus('Connected. Waiting for epochs‚Ä¶'); };
    this.ctrl.onmessage = (ev)=>{
      const m = JSON.parse(ev.data);
      if (m.type==='PING'){ this.ctrl.send(JSON.stringify({type:'PONG', t:m.t})); return; }
      if (m.type==='TASK' && m.kind==='GA_EPOCH'){
        const res = runEpochLocal(m.params);
        try{ this.ctrl.send(JSON.stringify({ type:'RESULT', id:m.id, kind:'GA_EPOCH', result:res })); }catch(e){ log('Send error', e?.message||e); }
      }
    };
  }
  async acceptOffer(offer, from){ await this.pc.setRemoteDescription(offer); const ans=await this.pc.createAnswer(); await this.pc.setLocalDescription(ans); sigSend({ type:'ANSWER', room:roomId, to:from, from:peerId, sdp:ans }); }
}

/***** GA scheduling (coordinator) *****/
let pending = []; const inFlightById = new Map();
let elitePool = []; // array of {route,len}

function planEpochJobs(){
  const k = Math.max(1, workers.size);
  const params = {
    cities: CITY,
    pop: parseInt($("#pop").value,10),
    gens: parseInt($("#gens").value,10),
    mutPct: parseFloat($("#mut").value)/100,
    elites: parseInt($("#elites").value,10),
    migrants: elitePool.slice(0, 12) // share top elites globally
  };
  const jobs = [];
  let i=0;
  for (const [id,p] of workers){
    jobs.push({ id:`ep_${epochNo}_${i++}_${Math.random().toString(36).slice(2,6)}`, params });
  }
  return jobs;
}

function scheduleLoop(){
  let made=false;
  for(let guard=0; guard< pending.length * 2; guard++){
    if (!pending.length) break;
    let best=null, bestScore=Infinity;
    for(const p of workers.values()){
      if (!p.canSend()) continue;
      const score = (p.inflight||0) + 0.003*(p.rtt||120) - 0.1*(p.epochs||0);
      if (score<bestScore){ best=p; bestScore=score; }
    }
    if (!best) break;
    const job = pending.shift();
    const ok = best.sendEpoch(job);
    if (ok){ inFlightById.set(job.id, { job, peer:best.id, ts:Date.now() }); made=true; }
    else { pending.unshift(job); break; }
  }
  if (made) refreshWorkersUI();
}

function startEpoch(){
  if (!running || !workers.size) return;
  pill($("#epoch"), String(++epochNo), "ok");
  const jobs = planEpochJobs();
  pending = jobs;
  scheduleLoop();
}

/***** Result handling *****/
function handleEpochResult(fromId, id, result){
  inFlightById.delete(id);
  // result: { best:{route,len}, elites:[{route,len}...] }
  if (result?.best && result.best.len < BEST.len){
    BEST = result.best; draw();
    log("New BEST", BEST.len.toFixed(2), "from", String(fromId).slice(0,6));
  }
  // merge elites
  elitePool = elitePool.concat(result.elites || []);
  elitePool.sort((a,b)=>a.len-b.len);
  if (elitePool.length>200) elitePool.length = 200;

  // when all jobs for this epoch done ‚Üí next epoch
  const anyLeft = [...inFlightById.values()].some(rec => rec.job.params && rec.job.id.startsWith(`ep_${epochNo}_`));
  if (!anyLeft && pending.length===0){ startEpoch(); }
}

/***** Timeout / requeue *****/
setInterval(()=>{
  const now=Date.now();
  for (const [id, rec] of [...inFlightById]){
    if (now - rec.ts > EPOCH_TIMEOUT_MS){
      log('Epoch task timeout ‚Üí requeue', id);
      pending.push(rec.job);
      inFlightById.delete(id);
      const p = workers.get(rec.peer); if (p){ p.inflight=Math.max(0,p.inflight-1); refreshWorkersUI(); }
    }
  }
  if (pending.length) scheduleLoop();
}, 800);

/***** GA core (shared) *****/
function routeLen(route, cities){
  let s=0, n=route.length;
  for (let i=0;i<n;i++){
    const a=cities[route[i]], b=cities[route[(i+1)%n]];
    const dx=a.x-b.x, dy=a.y-b.y; s += Math.hypot(dx,dy);
  }
  return s;
}
function randPerm(n){
  const arr=Array.from({length:n},(_,i)=>i);
  for(let i=n-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr;
}
function mutateSwap(route){
  const a=(Math.random()*route.length)|0, b=(Math.random()*route.length)|0;
  [route[a],route[b]]=[route[b],route[a]];
}
function oxCrossover(p1,p2){
  const n=p1.length, a=(Math.random()*n)|0, b=(Math.random()*n)|0;
  const lo=Math.min(a,b), hi=Math.max(a,b);
  const child=new Array(n).fill(-1);
  for(let i=lo;i<=hi;i++) child[i]=p1[i];
  let pos=(hi+1)%n;
  for(let i=0;i<n;i++){
    const gene=p2[(hi+1+i)%n];
    if (!child.includes(gene)){
      child[pos]=gene; pos=(pos+1)%n;
    }
  }
  return child;
}
function tournament(pop, fit, k=3){
  let best=-1, bestF=Infinity;
  for(let i=0;i<k;i++){
    const idx=(Math.random()*pop.length)|0;
    if (fit[idx]<bestF){ bestF=fit[idx]; best=idx; }
  }
  return best;
}

/* Run a worker epoch: evolve local population & return elites */
function runEpochLocal(p){
  const cities = p.cities;
  const N = cities.length;
  const popSize = p.pop|0;
  const gens = p.gens|0;
  const mutProb = p.mutPct||0.05;
  // seed population: some random, some from migrants
  const migrants = (p.migrants||[]).slice(0, Math.min(20, popSize>>2)).map(e=>e.route.slice());
  const pop = [];
  for (const m of migrants){ pop.push(m.slice()); }
  while (pop.length<popSize) pop.push(randPerm(N));

  const fit = new Array(pop.length);
  const evalAll = ()=>{ for (let i=0;i<pop.length;i++) fit[i]=routeLen(pop[i], cities); };
  evalAll();

  for (let g=0; g<gens; g++){
    const next = [];
    // elitism: keep the best 2
    let idxs = [...pop.keys()].sort((a,b)=>fit[a]-fit[b]).slice(0,2);
    next.push(pop[idxs[0]].slice(), pop[idxs[1]].slice());
    while (next.length < popSize){
      const a = pop[tournament(pop,fit,3)], b = pop[tournament(pop,fit,3)];
      let child = oxCrossover(a,b);
      if (Math.random()<mutProb) mutateSwap(child);
      next.push(child);
    }
    // replace and eval
    pop.length=0; Array.prototype.push.apply(pop, next);
    evalAll();
  }

  // elites
  const order = [...pop.keys()].sort((a,b)=>fit[a]-fit[b]);
  const elites = order.slice(0, p.elites||5).map(i=>({ route: pop[i].slice(), len: fit[i] }));
  const best = elites[0];

  return { best, elites };
}

/***** UI *****/
$("#start").onclick = async () => {
  try {
    $("#start").disabled = true; isCoord = true;
    roomId = (crypto.randomUUID?.() || Math.random().toString(36).slice(2,10)).replace(/-/g,'');
    setStatus("Creating room‚Ä¶"); await openSignaling(roomId);
    const base = location.origin + location.pathname; const url = base + `#room=${roomId}&role=worker`;
    $("#invite").value = url;
    $("#copy").onclick = () => navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));
    $("#share").onclick = () => navigator.share ? navigator.share({title:"NyxMesh Session",text:"Join my GA cluster",url}) : navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));
    $("#qr").onclick = () => showQR(url);
    $("#open").onclick = () => { const w = window.open('about:blank'); if (w) w.location.href = url; };
    $("#open").disabled = false;

    setDebug({ SIGNAL_URL, roomId, role:"coordinator", invite:url, peerId });
    setStatus("Room created. Waiting for workers to join‚Ä¶");
  } catch (e) {
    setStatus("Failed to start: " + (e?.message||e)); $("#start").disabled=false;
  }
};

$("#run").onclick = () => {
  if (!workers.size){ setStatus("No workers connected"); return; }
  const n = parseInt($("#cities").value,10);
  if ($("#reset").value==='yes' || CITY.length!==n){ genCities(n); BEST={route:null,len:Infinity}; draw(); }
  running = true; epochNo=0; elitePool.length=0;
  $("#run").disabled=true; $("#stop").disabled=false; $("#snapshot").disabled=false;
  setStatus(`Optimizing TSP: ${n} cities ‚Ä¢ ${workers.size} workers`);
  startEpoch();
};

$("#stop").onclick = () => {
  running=false; pending.length=0; setStatus("Stopped."); $("#run").disabled=false; $("#stop").disabled=true;
};

$("#snapshot").onclick = () => {
  const a=document.createElement('a'); a.download=`tsp_best_${CITY.length}.png`; a.href=canvas.toDataURL('image/png'); a.click();
};

function enableRunIfReady(){
  if (!isCoord) return;
  const anyUsable = [...workers.values()].some(p => p.wsOnly || p.ctrl?.readyState==='open');
  $("#run").disabled = !anyUsable;
  if (anyUsable) setStatus('Ready. Recruit workers and hit ‚ñ∂Ô∏è Start.');
}

/***** Worker auto-join *****/
(async ()=>{
  const params = new URLSearchParams(location.hash.slice(1));
  const rid = params.get('room'); const role = params.get('role'); if (!rid) return;
  roomId = rid; isCoord = (role !== 'worker');
  setStatus(isCoord? 'Coordinator mode' : 'Joining room as worker‚Ä¶'); log(isCoord? 'Coordinator' : 'Worker', 'peerId=', peerId, 'room=', roomId);
  try {
    await openSignaling(roomId);
    if (!isCoord){
      workerConn = new WorkerConn(); await workerConn.start();
      setDebug({ SIGNAL_URL, roomId, role:'worker', peerId });
      $("#start").disabled=true; $("#run").disabled=true;
    } else {
      setDebug({ SIGNAL_URL, roomId, role:'coordinator', peerId });
      enableRunIfReady();
    }
  } catch(e){ setStatus('Join failed: ' + (e?.message||e)); }
})();

/***** QR *****/
function showQR(data){
  let div = document.getElementById('qrModal'); if (!div){
    div = document.createElement('div'); div.id='qrModal'; div.style.position='fixed'; div.style.inset='0'; div.style.background='rgba(0,0,0,.6)'; div.style.display='grid'; div.style.placeItems='center'; div.style.zIndex='9999';
    const inner = document.createElement('div'); inner.style.background='#12121a'; inner.style.border='1px solid #2b2b3a'; inner.style.borderRadius='12px'; inner.style.padding='14px'; inner.style.textAlign='center';
    const img = document.createElement('img'); img.id='qrImg'; img.width=220; img.height=220; img.alt='QR'; img.style.borderRadius='10px'; img.style.background='#fff';
    const p = document.createElement('div'); p.className='mono'; p.style.wordBreak='break-all'; p.style.marginTop='8px'; p.textContent=data;
    const c = document.createElement('button'); c.className='btn secondary'; c.textContent='Close'; c.onclick=()=>div.remove();
    inner.appendChild(img); inner.appendChild(p); inner.appendChild(c); div.appendChild(inner); document.body.appendChild(div);
  }
  const img = document.getElementById('qrImg');
  const api = 'https://api.qrserver.com/v1/create-qr-code/?size=220x220&data=' + encodeURIComponent(data);
  img.src = api;
}
</script>
</body>
</html>
