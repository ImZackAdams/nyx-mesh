<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NyxMesh ‚Ä¢ P2P Blackjack Simulator (Multi-Worker, WS/RTC)</title>
<style>
  :root{--bg:#0b0b0f;--panel:#16161d;--ink:#eaeaf2;--muted:#a7a7b3;--accent:#9b5cff;--accent-hover:#b47dff;--good:#7dff8b;--warn:#ffe57d;--bad:#ff7d7d}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:radial-gradient(1200px 600px at 10% 0%,#141421 0%,var(--bg) 60%);color:var(--ink);display:flex;justify-content:center;padding:18px}
  .wrap{width:100%;max-width:1200px;display:grid;grid-template-columns:380px 1fr;gap:14px}
  .card{background:var(--panel);border:1px solid #222231;border-radius:14px;padding:14px}
  h1{margin:0 0 8px;font-size:18px} h2{margin:12px 0 10px;font-size:15px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);color:#0b0b0f;border:0;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;transition:.2s}
  .btn:hover{background:var(--accent-hover);transform:translateY(-1px)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.secondary{background:#2a2a38;color:var(--ink);border:1px solid #333349}
  .btn.ghost{background:transparent;border:1px dashed #333349;color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  input,select,textarea{width:100%;background:#0f0f16;color:#0ef;border:1px solid #282838;border-radius:8px;padding:10px}
  .kv{display:flex;justify-content:space-between;border-bottom:1px dashed #2a2a3a;padding:4px 0}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#24243a;color:var(--ink);font-size:12px}
  .ok{background:#1d3d23;color:var(--good)}.warn{background:#3d3d1d;color:var(--warn)}.bad{background:#3d1d1d;color:var(--bad)}
  .log{height:220px;overflow:auto;background:#0e0e15;border:1px solid #242436;border-radius:8px;padding:8px}
  .status{margin-top:10px;padding:8px;border-radius:8px;background:#1a1a24;border:1px solid #2a2a3a;font-size:13px}
  canvas{width:100%;height:auto;background:#0c0c14;border:1px solid #242436;border-radius:10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid.single{grid-template-columns:1fr}
  label small{color:var(--muted);display:block;margin-top:4px}
  .workers{margin-top:6px;display:flex;flex-direction:column;gap:6px}
  .worker{display:grid;grid-template-columns:1fr auto auto auto;gap:8px;align-items:center;padding:8px;border:1px solid #2b2b3a;border-radius:10px;background:#12121a}
  .muted{color:var(--muted)}
  .caps{font-variant:all-small-caps;letter-spacing:.04em}
  @media (max-width: 860px) {.wrap{grid-template-columns:1fr}.card:first-child{order:2}.card:last-child{order:1}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>üÉè NyxMesh Blackjack (Multi-Worker)</h1>
    <div class="kv"><span>Signaling</span><span id="sigState" class="pill">idle</span></div>
    <div class="kv"><span>Workers</span><span id="workerCount" class="pill">0</span></div>
    <div class="kv"><span>Scheduler</span><span id="sched" class="pill">idle</span></div>

    <h2>Session</h2>
    <div class="row"><button id="start" class="btn">Start Session</button></div>
    <div class="row" style="margin-top:8px">
      <input id="invite" class="mono" placeholder="Invite link appears here" readonly />
      <button id="copy" class="btn secondary" title="Copy link">Copy</button>
      <button id="share" class="btn secondary" title="Share link">Share</button>
      <button id="qr" class="btn secondary" title="Show QR">QR</button>
      <button id="open" class="btn secondary" title="Open worker tab" disabled>Open worker</button>
    </div>
    <div class="status" id="status">Create a session and send the link to workers.</div>

    <h2>Simulation Controls</h2>
    <div class="grid">
      <label>Hands per cell
        <input id="hands" type="number" value="5000" min="100" step="100"/>
        <small>Monte Carlo runs per (player total √ó dealer upcard)</small>
      </label>
      <label>Policy
        <select id="policy">
          <option value="basic" selected>Basic-ish Strategy</option>
          <option value="hitStandFixed">Hit below N</option>
        </select>
        <small>Player decision rule</small>
      </label>
    </div>
    <div class="grid" style="margin-top:8px">
      <label>Hit below (for Hit/Stand)
        <input id="hitBelow" type="number" value="17" min="5" max="21"/>
        <small>Only used for ‚ÄúHit below N‚Äù policy</small>
      </label>
      <label>Dealer Rule
        <select id="dealerRule">
          <option value="S17" selected>Stand on soft 17</option>
          <option value="H17">Hit soft 17</option>
        </select>
        <small>Common casino rule toggle</small>
      </label>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="simulate" class="btn" disabled>‚ñ∂Ô∏è Run Simulation</button>
      <button id="download" class="btn ghost" disabled>Download PNG</button>
    </div>

    <h2>Workers</h2>
    <div id="workers" class="workers"></div>

    <h2>Debug</h2>
    <textarea id="debug" rows="6" class="mono" readonly></textarea>
  </div>

  <div class="card">
    <h1>üìà EV Heatmap (Hard Totals)</h1>
    <canvas id="canvas" width="800" height="640"></canvas>
    <div class="row" style="margin-top:8px">
      <span class="pill ok">Green = +EV</span>
      <span class="pill bad">Red = ‚àíEV</span>
      <span class="pill">Label shows EV / hand</span>
    </div>
    <h2>Activity</h2>
    <pre id="log" class="log mono"></pre>
  </div>
</div>

<script>
/***** CONFIG *****/
const DEFAULT_SIGNAL_URL = (location.protocol === "https:" ? "wss://" : "ws://")
  + ((location.hostname && location.hostname !== "") ? location.hostname : "localhost")
  + ":" + ((location.port && location.port !== "") ? location.port : "8080");
let SIGNAL_URL = DEFAULT_SIGNAL_URL;
(() => { const u = new URL(location.href); const override = u.searchParams.get("signal"); if (override) SIGNAL_URL = override; })();
const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];
const MAX_INFLIGHT_PER_WORKER = 6;
const JOB_TIMEOUT_MS = 12000;

/***** DOM helpers *****/
const $ = s => document.querySelector(s);
function pill(el, text, cls){ el.textContent = text; el.className = "pill " + (cls||""); }
function setStatus(msg){ $("#status").textContent = msg; }
function setDebug(o){ $("#debug").value = JSON.stringify(o, null, 2); }
const logEl = $("#log");
function log(...a){ const ts=new Date().toLocaleTimeString(); logEl.textContent += `[${ts}] ${a.join(" ")}\n`; logEl.scrollTop = logEl.scrollHeight; }

/***** Global state *****/
const peerId = (crypto.randomUUID?.() || Math.random().toString(36).slice(2,10)).replace(/-/g,'');
let roomId = null, isCoord = false;
let sig = null; // WebSocket
let renderState = { inProgress:false, jobsTotal:0, jobsDone:0, startTime:0 };
const canvas = $("#canvas"); const ctx = canvas.getContext("2d");
let CANVAS_W = canvas.width, CANVAS_H = canvas.height;

/***** Workers UI *****/
const workers = new Map(); // peerId -> Peer
function refreshWorkersUI(){
  $("#workerCount").textContent = String(workers.size);
  const host = $("#workers"); host.innerHTML = "";
  for (const p of workers.values()){
    const el = document.createElement('div'); el.className = 'worker'; el.id = `w-${p.id}`;
    el.innerHTML = `
      <div class="mono">${p.id.slice(0,8)} <span class="muted caps">${p.wsOnly? 'ws-only' : p.state}</span></div>
      <div class="pill ${p.rtt<80?'ok':p.rtt<200?'warn':'bad'}" title="RTT">${p.rtt? p.rtt+"ms":"‚Äî"}</div>
      <div class="pill" title="In flight">${p.inflight}</div>
      <div class="pill" title="Jobs/sec">${p.tilesPerSec.toFixed(1)}</div>`;
    host.appendChild(el);
  }
}

/***** Signaling *****/
function sigSend(obj){ if(sig && sig.readyState === WebSocket.OPEN) sig.send(JSON.stringify(obj)); }
function openSignaling(id){
  return new Promise((res) => {
    sig = new WebSocket(SIGNAL_URL);
    sig.onopen = () => {
      pill($("#sigState"), "open", "ok");
      log("WS connected", SIGNAL_URL);
      sigSend({ type:"JOIN", room:id, peer:peerId, role:isCoord? 'coordinator':'worker' });
      sigSend({ type:"HELLO", room:id, from:peerId, role:isCoord? 'coordinator':'worker' });
      res();
    };
    sig.onmessage = async (e) => { let m; try { m = JSON.parse(e.data); } catch { return; } await onSignal(m); };
    sig.onerror = (err) => { log("WS error", err?.message||err); pill($("#sigState"), "error", "bad"); };
    sig.onclose = () => { pill($("#sigState"), "closed", "bad"); };
  });
}

async function onSignal(m){
  if (m.room && m.room !== roomId) return;

  // Worker-only WS fallback jobs
  if (!isCoord && m.type === 'TASK_WS' && m.to === peerId){
    if (m.kind === 'BJ_BATCH'){
      const res = simulateBlackjackBatch(m.params);
      sigSend({ type:'RESULT_WS', room:roomId, from:peerId, id:m.id, kind:'BJ_BATCH', result:res, state:m.params.state });
    }
    return;
  }

  if (isCoord){
    if (m.type === 'HELLO' && m.from && m.from !== peerId){ ensurePeer(m.from).maybeConnect(); return; }
    if (m.type === 'PEER_JOINED' && m.peer){ ensurePeer(m.peer).maybeConnect(); return; }
    if (m.type === 'ANSWER' && m.from){ const p = workers.get(m.from); if (p) await p.acceptAnswer(m.sdp); return; }
    if (m.type === 'ICE' && m.from){ const p = workers.get(m.from); if (p) try{ await p.pc?.addIceCandidate(m.candidate); }catch{} return; }
    if (m.type === 'RESULT_WS' && m.from){ handleBJResultWS(m); return; }
  } else {
    if (m.type === 'OFFER' && (m.to===peerId || !m.to)){
      if (!workerConn) { workerConn = new WorkerConn(); await workerConn.start(); }
      await workerConn.acceptOffer(m.sdp, m.from);
      return;
    }
    if (m.type === 'ICE' && (m.to===peerId || !m.to)){
      try { await workerConn?.pc?.addIceCandidate(m.candidate); } catch {}
      return;
    }
  }
}

/***** Coordinator: Peer wrapper *****/
class Peer{
  constructor(id){
    this.id=id; this.pc=null; this.ctrl=null; this.data=null; this.state='idle';
    this.rtt=0; this._rttEMA=null; this._pingTimer=null; this.inflight=0;
    this.wsOnly=false; this.tilesPerSec=0; this._recvTiles=0; this._recvWindowStart=performance.now();
    this.pendingMeta=[]; this.offerRetry=null; this._everConnected=false;
  }
  async maybeConnect(){
    if (this.pc || this.wsOnly) return;
    this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 });
    this.pc.onconnectionstatechange = () => {
      const s=this.pc.connectionState; this.state = s; refreshWorkersUI();
      if (s==='connected'){ clearInterval(this.offerRetry); enableSimIfReady(); }
      if (s==='failed' || s==='closed' || s==='disconnected'){
        if (!this._everConnected){
          this.wsOnly = true;
          log('RTC failed for', this.id, '‚Üí WS fallback'); refreshWorkersUI(); enableSimIfReady();
        }
      }
    };
    this.pc.oniceconnectionstatechange = () => refreshWorkersUI();
    this.pc.onicecandidate = (e) => { if(e.candidate) sigSend({ type:'ICE', room:roomId, to:this.id, from:peerId, candidate:e.candidate }); };

    // Data channels
    this.ctrl = this.pc.createDataChannel('ctrl',{ordered:true});
    this.data = this.pc.createDataChannel('data',{ordered:true});
    this.data.binaryType = 'arraybuffer';
    this.data.bufferedAmountLowThreshold = 1<<20;

    this.wireCtrl(); this.wireData();

    const offer = await this.pc.createOffer(); await this.pc.setLocalDescription(offer);
    sigSend({ type:'OFFER', room:roomId, to:this.id, from:peerId, sdp:offer });
    this.offerRetry = setInterval(async()=>{
      if (this.pc?.connectionState==='connected' || this.pc?.remoteDescription?.type==='answer') { clearInterval(this.offerRetry); return; }
      try{ const o = await this.pc.createOffer(); await this.pc.setLocalDescription(o); sigSend({ type:'OFFER', room:roomId, to:this.id, from:peerId, sdp:o }); log('Offer retry ‚Üí', this.id); }catch{}
    }, 3000);
  }
  async acceptAnswer(ans){ await this.pc.setRemoteDescription(ans); this._everConnected = true; }
  wireCtrl(){
    this.ctrl.onopen = ()=>{ this.state='dc-open'; this._startPings(); refreshWorkersUI(); enableSimIfReady(); };
    this.ctrl.onmessage = (ev)=>{
      const m = JSON.parse(ev.data);
      if (m.type==='PONG'){
        const rtt = Date.now()-m.t;
        this._rttEMA = this._rttEMA==null? rtt : (0.8*this._rttEMA + 0.2*rtt);
        this.rtt = Math.round(this._rttEMA);
        refreshWorkersUI();
      }
      if (m.type==='RESULT_META'){ this.pendingMeta.push(m); }
    };
  }
  wireData(){
    this.data.onmessage = (ev)=>{
      const meta = this.pendingMeta.shift();
      if (!meta){ log('WARN: data w/o meta from', this.id); return; }
      if (meta.kind === 'BJ_BATCH'){
        const dv = new DataView(ev.data);
        const total = dv.getFloat64(0, true);
        const count = dv.getFloat64(8, true);
        onBJResult(meta.id, meta.state, { total, count }, this.id);
      }
      this.inflight = Math.max(0, this.inflight-1);
      this._recvTiles++;
      const now = performance.now();
      if (now - this._recvWindowStart > 1000){
        this.tilesPerSec = this._recvTiles / ((now - this._recvWindowStart)/1000);
        this._recvTiles = 0; this._recvWindowStart = now; refreshWorkersUI();
      }
    };
  }
  _startPings(){ this._pingTimer = setInterval(()=>{ this.ctrl?.send(JSON.stringify({type:'PING', t:Date.now()})); }, 5000); }
  canSend(){
    return (this.wsOnly) || (this.ctrl?.readyState==='open' && this.data?.readyState==='open'
      && this.inflight < MAX_INFLIGHT_PER_WORKER && this.data.bufferedAmount < (4<<20));
  }
  sendBJ(job){
    if (this.wsOnly){
      sigSend({ type:'TASK_WS', room:roomId, to:this.id, from:peerId, id:job.id, kind:'BJ_BATCH', params:job.params });
      this.inflight++; return true;
    }
    try{
      this.ctrl.send(JSON.stringify({ type:'TASK', id:job.id, kind:'BJ_BATCH', params: job.params }));
      this.inflight++; return true;
    }catch{ return false; }
  }
}
function ensurePeer(id){
  let p = workers.get(id);
  if (!p){ p = new Peer(id); workers.set(id,p); refreshWorkersUI(); enableSimIfReady(); }
  return p;
}

/***** Worker side connection *****/
let workerConn = null;
class WorkerConn{
  constructor(){ this.pc=null; this.ctrl=null; this.data=null; }
  async start(){
    this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS, iceCandidatePoolSize: 10 });
    this.pc.ondatachannel = (e)=>{ if (e.channel.label==='ctrl'){ this.ctrl=e.channel; this.wireCtrl(); } else if (e.channel.label==='data'){ this.data=e.channel; this.data.binaryType='arraybuffer'; } };
    this.pc.onicecandidate = (e)=>{ if(e.candidate) sigSend({ type:'ICE', room:roomId, to:'coordinator', from:peerId, candidate:e.candidate }); };
  }
  wireCtrl(){
    this.ctrl.onopen = ()=>{ setStatus('Connected. Waiting for jobs‚Ä¶'); };
    this.ctrl.onmessage = (ev)=>{
      const m = JSON.parse(ev.data);
      if (m.type==='PING'){ this.ctrl.send(JSON.stringify({type:'PONG', t:m.t})); return; }
      if (m.type==='TASK' && m.kind==='BJ_BATCH'){
        const res = simulateBlackjackBatch(m.params);
        try{
          this.ctrl.send(JSON.stringify({ type:'RESULT_META', id:m.id, kind:'BJ_BATCH', state:m.params.state }));
          const buf = new ArrayBuffer(16); const dv = new DataView(buf);
          dv.setFloat64(0, res.total, true); dv.setFloat64(8, res.count, true);
          this.data?.send(buf);
        }catch(e){ log('Send error', e?.message||e); }
      }
    };
  }
  async acceptOffer(offer, from){
    await this.pc.setRemoteDescription(offer);
    const ans=await this.pc.createAnswer(); await this.pc.setLocalDescription(ans);
    sigSend({ type:'ANSWER', room:roomId, to:from, from:peerId, sdp:ans });
  }
}

/***** Scheduler (jobs) *****/
let pendingJobs = [];
const inFlightById = new Map();

function planBJJobs(handsPerCell){
  // Player hard totals 8..21 vs dealer upcard [2..11(Ace)]
  const jobs = [];
  for (let pSum=8; pSum<=21; pSum++){
    for (const dUp of [2,3,4,5,6,7,8,9,10,11]){
      const state = { playerSum:pSum, playerSoft:false, dealerUp:dUp };
      const params = {
        seed: (Math.random()*1e9)|0,
        hands: handsPerCell,
        state,
        policy: $("#policy").value,
        hitBelow: parseInt($("#hitBelow").value,10),
        dealerRule: $("#dealerRule").value
      };
      jobs.push({ id:`bj_${Math.random().toString(36).slice(2,8)}`, params });
    }
  }
  return jobs;
}

function scheduleLoop(){
  let made = false;
  for(let guard=0; guard< pendingJobs.length * 2; guard++){
    if (!pendingJobs.length) break;
    let best=null, bestScore=Infinity;
    for(const p of workers.values()){
      if (!p.canSend()) continue;
      const score = (p.inflight || 0) + 0.003 * (p.rtt || 120) - 0.2 * (p.tilesPerSec || 0);
      if (score < bestScore) { best = p; bestScore = score; }
    }
    if (!best) break;
    const job = pendingJobs.shift();
    const ok = best.sendBJ(job);
    if (ok){
      inFlightById.set(job.id, { job, peer:best.id, ts:Date.now() });
      made = true;
    } else { pendingJobs.unshift(job); break; }
  }
  pill($("#sched"), pendingJobs.length? `queued ${pendingJobs.length}` : 'idle', pendingJobs.length? 'warn':'ok');
  if (made) refreshWorkersUI();
}

function onBJResult(id, state, res, fromId){
  renderState.jobsDone++;
  inFlightById.delete(id);
  accumulateEV(state, res);
  drawHeatmap();
  const pct=Math.round(100*renderState.jobsDone/renderState.jobsTotal);
  const elapsed=((Date.now()-renderState.startTime)/1000).toFixed(1);
  log(`Cell ${renderState.jobsDone}/${renderState.jobsTotal} (${pct}%) - ${elapsed}s (from ${String(fromId).slice(0,6)})`);
  setStatus(`Simulating: ${pct}%`);
  if (renderState.jobsDone>=renderState.jobsTotal){
    renderState.inProgress=false;
    $("#simulate").disabled=false; $("#download").disabled=true; // download after redraw for better labels
    const total=((Date.now()-renderState.startTime)/1000).toFixed(1);
    setStatus(`Simulation complete ‚úì (${total}s)`);
    $("#download").disabled=false;
  }
  scheduleLoop();
}

// Requeue stale jobs
setInterval(()=>{
  const now = Date.now();
  for (const [id, rec] of [...inFlightById]){
    if (now - rec.ts > JOB_TIMEOUT_MS){
      log('Timeout ‚Üí requeue', id);
      pendingJobs.push({ id:`re_${Math.random().toString(36).slice(2,8)}`, params: rec.job.params });
      inFlightById.delete(id);
      const p = workers.get(rec.peer); if (p){ p.inflight = Math.max(0, p.inflight-1); refreshWorkersUI(); }
    }
  }
  if (pendingJobs.length) scheduleLoop();
}, 1000);

/***** EV aggregation + drawing *****/
const aggEV = new Map(); // key "sum_soft_dealer" -> {total,count}
function keyFor(state){ return `${state.playerSum}_${state.playerSoft?1:0}_${state.dealerUp}`; }
function accumulateEV(state, res){
  const k = keyFor(state);
  const prev = aggEV.get(k) || { total:0, count:0 };
  aggEV.set(k, { total: prev.total + res.total, count: prev.count + res.count });
}
function drawHeatmap(){
  const cols = 10; // dealer 2..A
  const rows = 14; // player 8..21
  const cellW = Math.floor(CANVAS_W / cols), cellH = Math.floor(CANVAS_H / rows);
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
  // axes labels
  ctx.fillStyle="#a7a7b3"; ctx.font="12px ui-monospace";
  for (let i=0;i<cols;i++){ const label = (i<8)? String(i+2) : (i===8? "10" : "A"); ctx.fillText(label, i*cellW + cellW/2 - 6, 14); }
  for (let r=0;r<rows;r++){ ctx.fillText(String(8+r), 4, r*cellH + 14); }

  for (let r=0, pSum=8; r<rows; r++, pSum++){
    for (let c=0, dUp=2; c<cols; c++, dUp = (c<8? 2+c : (c===8?10:11))){
      const k = `${pSum}_0_${dUp}`;
      const rec = aggEV.get(k);
      let ev = 0, seen=false;
      if (rec && rec.count>0){ ev = rec.total / rec.count; seen=true; }
      // color map EV in [-0.5, +0.5]
      const t = Math.max(-0.5, Math.min(0.5, ev));
      const g = Math.floor((t+0.5) * 255);
      const rr = 255 - g;
      ctx.fillStyle = seen? `rgb(${rr},${g},40)` : "#0c0c14";
      ctx.fillRect(c*cellW+1, r*cellH+1, cellW-2, cellH-2);
      if (seen){
        ctx.fillStyle="#fff"; ctx.font="12px ui-monospace";
        ctx.fillText(ev.toFixed(2), c*cellW + 6, r*cellH + 16);
      }
    }
  }
}

/***** WS result handler (fallback) *****/
function handleBJResultWS(m){
  onBJResult(m.id, m.state, m.result, m.from);
  const p = workers.get(m.from);
  if (p){ p.inflight = Math.max(0, p.inflight-1); refreshWorkersUI(); }
}

/***** Blackjack simulation core (worker + coord share) *****/
function xorshift32(seed){ let x = seed|0; return ()=>{ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; }; }
function drawCard(rng){
  const v = Math.floor(rng()*13)+1;
  if (v===1) return 11;           // Ace
  if (v>=10) return 10;           // 10,J,Q,K
  return v;                       // 2..9
}
function handValue(cards){
  let sum = cards.reduce((a,b)=>a+b,0);
  let aces = 0; for (const c of cards) if (c===11) aces++;
  while (sum>21 && aces>0){ sum -= 10; aces--; }
  const soft = (aces>0) && (sum<=21);
  return {sum, soft};
}
function basicDecision(player, dealerUp){
  const {sum, soft} = handValue(player);
  if (player.length===2 && !soft && sum>=9 && sum<=11 && dealerUp!==11) return "double";
  if (soft){
    if (sum<=17) return "hit";
    if (sum===18) return (dealerUp>=9 || dealerUp===11) ? "hit" : "stand";
    return "stand";
  } else {
    if (sum<=11) return "hit";
    if (sum===12) return (dealerUp>=4 && dealerUp<=6) ? "stand" : "hit";
    if (sum>=13 && sum<=16) return (dealerUp>=2 && dealerUp<=6) ? "stand" : "hit";
    return "stand";
  }
}
function playDealer(rng, up, dealerRule){ // S17/H17
  const hand = [up, drawCard(rng)];
  while (true){
    const {sum, soft} = handValue(hand);
    if (sum>21) return hand;
    if (sum>17) return hand;
    if (sum===17){
      if (soft && dealerRule==="H17"){ hand.push(drawCard(rng)); continue; }
      if (!soft || dealerRule==="S17") return hand;
    }
    hand.push(drawCard(rng));
  }
}
function resolveOutcome(player, dealer){
  const pv = handValue(player).sum, dv = handValue(dealer).sum;
  if (pv>21) return -1;
  if (dv>21) return +1;
  if (pv>dv) return +1;
  if (pv<dv) return -1;
  return 0;
}
function simulateOneHand(rng, params){
  const dealerUp = params.state.dealerUp;
  const dealerRule = params.dealerRule || "S17";
  // deal random player starting hand; this is a ‚Äúpolicy EV‚Äù sim, not strictly conditioned on exact total
  let player = [drawCard(rng), drawCard(rng)];
  // naturals
  const p0 = handValue(player).sum, d0 = handValue([dealerUp, drawCard(rng)]).sum;
  if (p0===21){ if (d0===21) return 0; return 1.5; } // 3:2
  if (d0===21) return -1;

  // player turn via chosen policy
  let doubled=false;
  while (true){
    const {sum} = handValue(player);
    if (sum>=21) break;
    let action = params.policy==="hitStandFixed"
      ? (sum < (params.hitBelow||17) ? "hit" : "stand")
      : basicDecision(player, dealerUp);
    if (action==="double" && player.length===2){ doubled=true; player.push(drawCard(rng)); break; }
    if (action==="stand") break;
    player.push(drawCard(rng));
  }
  const dealer = playDealer(rng, dealerUp, dealerRule);
  const delta = resolveOutcome(player, dealer);
  return doubled ? delta*2 : delta;
}
// Batch for a given state
function simulateBlackjackBatch(params){
  const rng = xorshift32(params.seed|0);
  let total=0, count=0;
  for (let i=0;i<params.hands;i++){
    total += simulateOneHand(rng, params);
    count++;
  }
  return { total, count };
}

/***** UI *****/
$("#start").onclick = async () => {
  try {
    $("#start").disabled = true; isCoord = true;
    roomId = (crypto.randomUUID?.() || Math.random().toString(36).slice(2,10)).replace(/-/g,'');
    setStatus("Creating room‚Ä¶"); await openSignaling(roomId);
    const base = location.origin + location.pathname; const url = base + `#room=${roomId}&role=worker`;
    $("#invite").value = url;
    $("#copy").onclick = () => navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));
    $("#share").onclick = () => navigator.share ? navigator.share({title:"NyxMesh Session",text:"Join my session",url}) : navigator.clipboard.writeText(url).then(()=>setStatus("Invite copied."));
    $("#qr").onclick = () => showQR(url);
    $("#open").onclick = () => { const w = window.open('about:blank'); if (w) w.location.href = url; };
    $("#open").disabled = false;

    setDebug({ SIGNAL_URL, roomId, role:"coordinator", invite:url, peerId });
    setStatus("Room created. Waiting for workers to join‚Ä¶");
  } catch (e) {
    setStatus("Failed to start: " + (e?.message||e)); $("#start").disabled=false;
  }
};

$("#simulate").onclick = () => {
  if (!workers.size){ setStatus("No workers connected"); return; }
  // reset aggregation & canvas
  aggEV.clear(); ctx.fillStyle="#0c0c14"; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

  const handsPerCell = parseInt($("#hands").value,10);
  const jobs = planBJJobs(handsPerCell);
  renderState = { inProgress:true, jobsTotal:jobs.length, jobsDone:0, startTime:Date.now() };
  setStatus(`Simulating: ${jobs.length} cells √ó ${handsPerCell} hands‚Ä¶`);
  $("#simulate").disabled=true; $("#download").disabled=true;
  pendingJobs = jobs;
  scheduleLoop();
};

$("#download").onclick = () => {
  const a = document.createElement('a');
  a.download = `blackjack_ev_${CANVAS_W}x${CANVAS_H}.png`;
  a.href = canvas.toDataURL('image/png');
  a.click();
};

function enableSimIfReady(){
  if (!isCoord) return;
  const anyUsable = [...workers.values()].some(p => p.wsOnly || p.ctrl?.readyState==='open');
  $("#simulate").disabled = !anyUsable;
  if (anyUsable) setStatus('Ready. Tune controls and hit ‚ñ∂Ô∏è Run Simulation.');
}

/***** QR *****/
function showQR(data){
  let div = document.getElementById('qrModal'); if (!div){
    div = document.createElement('div'); div.id='qrModal'; div.style.position='fixed'; div.style.inset='0'; div.style.background='rgba(0,0,0,.6)'; div.style.display='grid'; div.style.placeItems='center'; div.style.zIndex='9999';
    const inner = document.createElement('div'); inner.style.background='#12121a'; inner.style.border='1px solid #2b2b3a'; inner.style.borderRadius='12px'; inner.style.padding='14px'; inner.style.textAlign='center';
    const img = document.createElement('img'); img.id='qrImg'; img.width=220; img.height=220; img.alt='QR'; img.style.borderRadius='10px'; img.style.background='#fff';
    const p = document.createElement('div'); p.className='mono'; p.style.wordBreak='break-all'; p.style.marginTop='8px'; p.textContent=data;
    const c = document.createElement('button'); c.className='btn secondary'; c.textContent='Close'; c.onclick=()=>div.remove();
    inner.appendChild(img); inner.appendChild(p); inner.appendChild(c); div.appendChild(inner); document.body.appendChild(div);
  }
  const img = document.getElementById('qrImg');
  const api = 'https://api.qrserver.com/v1/create-qr-code/?size=220x220&data=' + encodeURIComponent(data);
  img.src = api;
}

/***** Auto-join as worker *****/
(async ()=>{
  const params = new URLSearchParams(location.hash.slice(1));
  const rid = params.get('room'); const role = params.get('role'); if (!rid) return;
  roomId = rid; isCoord = (role !== 'worker');
  setStatus(isCoord? 'Coordinator mode' : 'Joining room as worker‚Ä¶'); log(isCoord? 'Coordinator' : 'Worker', 'peerId=', peerId, 'room=', roomId);
  try {
    await openSignaling(roomId);
    if (!isCoord){
      workerConn = new WorkerConn(); await workerConn.start();
      setDebug({ SIGNAL_URL, roomId, role:'worker', peerId });
      $("#start").disabled=true; $("#simulate").disabled=true;
    } else {
      setDebug({ SIGNAL_URL, roomId, role:'coordinator', peerId });
      enableSimIfReady();
    }
  } catch(e){ setStatus('Join failed: ' + (e?.message||e)); }
})();
</script>
</body>
</html>
