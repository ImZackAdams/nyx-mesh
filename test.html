<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NyxMesh ‚Ä¢ Enhanced P2P Distributed Computing (Simplified)</title>
<style>
  :root { 
    --bg:#0b0b0f; --panel:#16161d; --ink:#eaeaf2; --muted:#a7a7b3; 
    --accent:#9b5cff; --accent-hover:#b47dff; --success:#7dff8b; --danger:#ff7d7d;
  }
  * { box-sizing: border-box; }
  html,body { height:100%; }
  body {
    margin:0; font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: radial-gradient(1200px 600px at 10% 0%, #141421 0%, var(--bg) 60%);
    color: var(--ink);
    display:flex; align-items:stretch; justify-content:center; padding:18px;
  }
  .wrap { width:100%; max-width:1200px; display:grid; grid-template-columns: 330px 1fr; gap:14px; }
  .card { background:var(--panel); border:1px solid #222231; border-radius:14px; padding:14px; }
  h1 { margin:0 0 8px 0; font-size:18px; letter-spacing:.3px; }
  h2 { margin:0 0 10px 0; font-size:15px; color:var(--muted); }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .btn {
    background:var(--accent); color:#0b0b0f; border:0; padding:8px 12px; border-radius:10px;
    font-weight:700; cursor:pointer; transition: all 0.2s;
  }
  .btn:hover:not(:disabled) { background:var(--accent-hover); transform: translateY(-1px); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn.secondary { background:#2a2a38; color:var(--ink); border:1px solid #333349; }
  .btn.danger { background:#ff4444; }
  .btn.success { background:#44ff44; color:#0b0b0f; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  textarea, input, select {
    width:100%; background:#0f0f16; color:var(--ink); border:1px solid #282838; 
    border-radius:8px; padding:10px; transition: border-color 0.2s;
  }
  textarea:focus, input:focus, select:focus { border-color:var(--accent); outline:none; }
  .grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .kv { display:flex; justify-content:space-between; border-bottom:1px dashed #2a2a3a; padding:4px 0; }
  .muted { color:var(--muted); }
  .log { height:250px; overflow:auto; background:#0e0e15; border:1px solid #242436; border-radius:8px; padding:8px; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#24243a; color:var(--ink); font-size:12px; transition: all 0.2s; }
  .ok { background:#1d3d23; color:#7dff8b; }
  .warn { background:#3d3d1d; color:#ffe57d; }
  .bad { background:#3d1d1d; color:#ff7d7d; }
  .info { background:#1d2d3d; color:#7dcfff; }
  .status-msg { margin-top:10px; padding:8px; border-radius:8px; background:#1a1a24; border:1px solid #2a2a3a; font-size:13px; }
  .perf-chart { height:120px; background:#0e0e15; border:1px solid #242436; border-radius:8px; padding:10px; margin-top:10px; position:relative; }
  .chart-bar { position:absolute; bottom:10px; width:8px; background:var(--accent); border-radius:4px 4px 0 0; transition:height .3s; }
  .task-selector { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin:10px 0; }
  .task-option { padding:8px; background:#1a1a24; border:2px solid #2a2a3a; border-radius:8px; cursor:pointer; text-align:center; transition:all .2s; }
  .task-option:hover { border-color:var(--accent); }
  .task-option.selected { background:var(--accent); color:#0b0b0f; border-color:var(--accent); }
  .stat-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:8px; margin-top:10px; }
  .stat-card { background:#1a1a24; border:1px solid #2a2a3a; border-radius:8px; padding:8px; text-align:center; }
  .stat-value { font-size:20px; font-weight:bold; color:var(--accent); }
  .stat-label { font-size:11px; color:var(--muted); }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>üöÄ NyxMesh Enhanced</h1>
      <div class="kv"><span>WebRTC</span><span id="cap-rtc" class="pill">‚Ä¶</span></div>
      <div class="kv"><span>WebGPU</span><span id="cap-gpu" class="pill">‚Ä¶</span></div>
      <div class="kv"><span>CPU Cores</span><span id="cap-cores" class="pill">‚Ä¶</span></div>
      <div class="kv"><span>GPU Score</span><span id="cap-gpuscore" class="pill">‚Ä¶</span></div>
      <div class="kv"><span>Memory (est.)</span><span id="cap-memory" class="pill">‚Ä¶</span></div>

      <h2>Network Role</h2>
      <div class="row">
        <label><input type="radio" name="role" value="coordinator" checked /> üì° Coordinator</label>
        <label><input type="radio" name="role" value="worker" /> ‚öôÔ∏è Worker</label>
      </div>
      <div id="role-status" class="status-msg" style="display:none;"></div>

      <h2>Connection Setup</h2>
      <div id="signal-instructions" class="status-msg">
        <strong>Quick Setup:</strong> Coordinator creates offer ‚Üí sends to Worker. Worker pastes offer ‚Üí creates answer ‚Üí sends back.
      </div>
      
      <textarea id="local" rows="4" class="mono" placeholder="Local offer/answer (auto-filled)" readonly></textarea>
      <div class="row" style="margin:8px 0;">
        <button class="btn" id="btn-create">Create Offer/Answer</button>
        <button class="btn secondary" id="btn-copy">üìã Copy</button>
      </div>
      
      <textarea id="remote" rows="4" class="mono" placeholder="Paste peer's offer/answer here (accepts URL / base64 / JSON)"></textarea>
      <div class="row" style="margin-top:8px;">
        <button class="btn" id="btn-remote">Set Remote</button>
        <button class="btn danger" id="btn-reset">üîÑ Reset All</button>
      </div>

      <h2>Connection Health</h2>
      <div class="kv"><span>Peer State</span><span id="pc-state" class="pill">idle</span></div>
      <div class="kv"><span>ICE State</span><span id="ice-state" class="pill">idle</span></div>
      <div class="kv"><span>Channel</span><span id="dc-state" class="pill">idle</span></div>
      <div class="kv"><span>Latency</span><span id="latency" class="pill">N/A</span></div>
      <div class="kv"><span>Throughput</span><span id="throughput" class="pill">N/A</span></div>

      <h2>Resource Configuration</h2>
      <div class="grid">
        <div><label class="muted">Max Threads
          <input id="concurrency" type="number" min="1" max="16" value="4" />
        </label></div>
        <div><label class="muted">Bandwidth (MB/s)
          <input id="bw" type="number" min="1" max="1000" value="100" />
        </label></div>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="btn-offer" disabled>üì¢ Publish Resources</button>
        <span id="offer-status" class="muted mono">idle</span>
      </div>
    </div>

    <div class="card" style="grid-column: 2;">
      <h1>‚ö° Compute Dashboard</h1>

      <div class="grid">
        <div class="card" style="padding:10px;">
          <h2>Task Configuration</h2>
          <div class="task-selector" id="task-types">
            <div class="task-option selected" data-type="matmul">Matrix Multiply</div>
            <div class="task-option" data-type="prime">Prime Search</div>
            <div class="task-option" data-type="mandelbrot">Mandelbrot</div>
            <div class="task-option" data-type="sort">Array Sort</div>
            <div class="task-option" data-type="hash">Hash Mining</div>
            <div class="task-option" data-type="monte">Monte Carlo œÄ</div>
          </div>
          
          <label class="muted">Problem Size
            <select id="task-size">
              <option value="128">Small (128)</option>
              <option value="256" selected>Medium (256)</option>
              <option value="512">Large (512)</option>
              <option value="1024">XLarge (1024)</option>
              <option value="2048">XXL (2048)</option>
            </select>
          </label>
          
          <div class="row" style="margin-top:10px;">
            <button class="btn success" id="btn-run" disabled>‚ñ∂Ô∏è Run Task</button>
            <button class="btn" id="btn-batch" disabled>üöÄ Run Batch (10)</button>
            <button class="btn" id="btn-stress" disabled>üí™ Stress Test</button>
          </div>
        </div>

        <div class="card" style="padding:10px;">
          <h2>Performance Metrics</h2>
          <div class="stat-grid">
            <div class="stat-card">
              <div class="stat-value" id="avg-gflops">0</div>
              <div class="stat-label">Avg GFLOPS</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="peak-gflops">0</div>
              <div class="stat-label">Peak GFLOPS</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="total-tasks">0</div>
              <div class="stat-label">Total Tasks</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="success-rate">0%</div>
              <div class="stat-label">Success Rate</div>
            </div>
          </div>
          <div class="perf-chart" id="perf-chart"></div>
        </div>
      </div>

      <div class="grid" style="margin-top:10px;">
        <div class="card" style="padding:10px;">
          <h2>üì§ Outbound Stats</h2>
          <div class="kv"><span>Tasks Sent</span><span id="stat-sent" class="pill">0</span></div>
          <div class="kv"><span>Results Accepted</span><span id="stat-accepted" class="pill">0</span></div>
          <div class="kv"><span>Avg Response Time</span><span id="stat-response" class="pill">N/A</span></div>
        </div>
        <div class="card" style="padding:10px;">
          <h2>üì• Inbound Stats</h2>
          <div class="kv"><span>Tasks Received</span><span id="stat-recv" class="pill">0</span></div>
          <div class="kv"><span>Tasks Completed</span><span id="stat-completed" class="pill">0</span></div>
          <div class="kv"><span>Compute Time</span><span id="stat-compute" class="pill">N/A</span></div>
        </div>
      </div>

      <div class="row" style="margin:10px 0;">
        <button class="btn secondary" id="btn-pause" disabled>‚è∏Ô∏è Pause Worker</button>
        <button class="btn secondary" id="btn-export">üìä Export Stats</button>
        <button class="btn secondary" id="btn-clear-log">Clear Log</button>
        <button class="btn secondary" id="btn-ping" disabled>üèì Ping</button>
      </div>

      <h2>Activity Monitor</h2>
      <pre id="log" class="log mono"></pre>
    </div>
  </div>

<script>
/* ==================== UTILITIES ==================== */
const $ = sel => document.querySelector(sel);
const $$ = sel => document.querySelectorAll(sel);

class Logger {
  constructor(element) { this.element = element; this.maxLines = 200; }
  log(...args) {
    const ts = new Date().toLocaleTimeString();
    const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a, null, 2)).join(' ');
    const line = `[${ts}] ${msg}\n`;
    this.element.textContent += line;
    const lines = this.element.textContent.split('\n');
    if (lines.length > this.maxLines) this.element.textContent = lines.slice(-this.maxLines).join('\n');
    this.element.scrollTop = this.element.scrollHeight;
  }
  clear(){ this.element.textContent=''; this.log('Log cleared'); }
}
const logger = new Logger($("#log"));
const log = (...args) => logger.log(...args);

function pill(el, text, cls = "") { el.textContent = text; el.className = "pill " + cls; }
function showStatus(msg, isError=false, duration=5000){
  const el=$("#role-status"); el.textContent=msg; el.style.display="block";
  el.style.background = isError ? "#3d1d1d" : "#1a1a24"; el.style.color = isError ? "#ff7d7d" : "#7dcfff";
  if (duration>0) setTimeout(()=>{ el.style.display="none"; }, duration);
}

/* ==================== SAFE CLIPBOARD + ENCODING ==================== */
const enc = s => btoa(unescape(encodeURIComponent(s)));
const dec = s => decodeURIComponent(escape(atob(s)));

async function safeCopy(text){
  if (document.hasFocus() && navigator.clipboard?.writeText) {
    try { await navigator.clipboard.writeText(text); return true; } catch {}
  }
  try {
    const ta = document.createElement('textarea');
    ta.value = text; ta.setAttribute('readonly','');
    ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
    document.body.appendChild(ta);
    ta.select(); ta.setSelectionRange(0, ta.value.length);
    const ok = document.execCommand('copy'); document.body.removeChild(ta);
    if (ok) return true;
  } catch {}
  // fall back: select in-place and let user copy manually
  $("#local").value = text; $("#local").focus(); $("#local").select();
  return false;
}

function parseRemote(input){
  const t=(input||"").trim(); if(!t) return null;
  if (t.startsWith("{")) { try{ JSON.parse(t); return t; }catch{} }
  try{ const u=new URL(t); const p=u.searchParams.get("offer")||u.searchParams.get("answer"); if(p){ const j=dec(p); JSON.parse(j); return j; } }catch{}
  try{ const j=dec(t); JSON.parse(j); return j; }catch{}
  return null;
}

/* ==================== SYSTEM CAPABILITIES ==================== */
class SystemCapabilities {
  constructor(){ this.caps = { rtc:false, gpu:false, cores:1, gpuScore:0, memory:0 }; }
  async probe(){
    this.caps.rtc = !!window.RTCPeerConnection;
    this.caps.gpu = !!navigator.gpu;
    this.caps.cores = navigator.hardwareConcurrency || 4;
    this.caps.gpuScore = this.caps.gpu ? this.caps.cores * 1000 : 0;
    this.caps.memory = navigator.deviceMemory || this.caps.cores * 2;
    pill($("#cap-rtc"), this.caps.rtc ? "ready" : "missing", this.caps.rtc ? "ok" : "bad");
    pill($("#cap-gpu"), this.caps.gpu ? "ready" : "missing", this.caps.gpu ? "ok" : "warn");
    pill($("#cap-cores"), String(this.caps.cores), "info");
    pill($("#cap-gpuscore"), String(this.caps.gpuScore), "info");
    pill($("#cap-memory"), `${this.caps.memory} GB`, "info");
    if (!this.caps.rtc) showStatus("‚ö†Ô∏è WebRTC not available in this browser!", true);
    return this.caps;
  }
}
let systemCaps = new SystemCapabilities();

/* ==================== PERFORMANCE TRACKER ==================== */
class PerformanceTracker {
  constructor(){
    this.history=[]; this.maxHistory=20;
    this.stats = { totalTasks:0, successfulTasks:0, totalGflops:0, peakGflops:0, totalComputeTime:0 };
  }
  addResult(result){
    const gflops = parseFloat(result.perf.gflops);
    this.history.push({ time:Date.now(), gflops, ms:result.perf.ms, size:result.perf.n });
    if (this.history.length > this.maxHistory) this.history.shift();
    this.stats.totalTasks++; this.stats.successfulTasks++; this.stats.totalGflops += gflops;
    this.stats.peakGflops = Math.max(this.stats.peakGflops, gflops);
    this.stats.totalComputeTime += result.perf.ms;
    this.updateUI(); this.drawChart();
  }
  updateUI(){
    const avgG = this.stats.totalTasks ? (this.stats.totalGflops/this.stats.totalTasks).toFixed(2) : 0;
    const rate = this.stats.totalTasks ? Math.round((this.stats.successfulTasks/this.stats.totalTasks)*100) : 0;
    $("#avg-gflops").textContent = avgG;
    $("#peak-gflops").textContent = this.stats.peakGflops.toFixed(2);
    $("#total-tasks").textContent = this.stats.totalTasks;
    $("#success-rate").textContent = `${rate}%`;
    if (this.stats.totalTasks > 0) $("#stat-compute").textContent = `${Math.round(this.stats.totalComputeTime / this.stats.totalTasks)}ms`;
  }
  drawChart(){
    const chart = $("#perf-chart"); chart.innerHTML = '';
    if (this.history.length === 0) return;
    const maxG = Math.max(...this.history.map(h=>h.gflops)); const H = 100;
    this.history.forEach((h,i)=>{
      const b = document.createElement('div'); b.className='chart-bar';
      b.style.left = `${10 + i*25}px`; b.style.height = `${(h.gflops/maxG)*H}px`;
      b.title = `${h.gflops.toFixed(2)} GFLOPS`;
      chart.appendChild(b);
    });
  }
}
let perfTracker = new PerformanceTracker();

/* ==================== TASK TYPES ==================== */
const TaskTypes = {
  matmul: { compute: function(params) {
    const n = params.n || 256;
    const A = new Float32Array(n * n);
    const B = new Float32Array(n * n);
    const C = new Float32Array(n * n);
    for (let i = 0; i < n * n; i++) { A[i] = Math.random()*2 - 1; B[i] = Math.random()*2 - 1; }
    const t0 = performance.now();
    for (let i = 0; i < n; i++) {
      for (let k = 0; k < n; k++) {
        const aik = A[i * n + k];
        for (let j = 0; j < n; j++) C[i*n + j] += aik * B[k*n + j];
      }
    }
    const t1 = performance.now();
    return { result:C, time:t1 - t0, ops: 2 * Math.pow(n,3) };
  }},
  prime: { compute: function(params) {
    const limit = params.n * 1000; const t0 = performance.now(); const primes = [];
    for (let n = 2; n <= limit && primes.length < params.n; n++) {
      let isPrime = true;
      for (let i = 2; i <= Math.sqrt(n); i++) if (n % i === 0) { isPrime = false; break; }
      if (isPrime) primes.push(n);
    }
    const t1 = performance.now();
    return { result:new Float32Array(primes), time:t1 - t0, ops: primes.length * Math.sqrt(limit) };
  }},
  mandelbrot: { compute: function(params) {
    const size = params.n, maxIter = 100; const result = new Float32Array(size * size);
    const t0 = performance.now();
    for (let y = 0; y < size; y++) for (let x = 0; x < size; x++) {
      const c_re = (x - size/2) * 4.0/size;
      const c_im = (y - size/2) * 4.0/size;
      let z_re = 0, z_im = 0, iter = 0;
      while (z_re*z_re + z_im*z_im <= 4 && iter < maxIter) {
        const tmp = z_re*z_re - z_im*z_im + c_re;
        z_im = 2*z_re*z_im + c_im; z_re = tmp; iter++;
      }
      result[y * size + x] = iter / maxIter;
    }
    const t1 = performance.now();
    return { result, time:t1 - t0, ops:size * size * maxIter };
  }},
  sort: { compute: function(params) {
    const size = params.n * 100; const arr = new Float32Array(size);
    for (let i = 0; i < size; i++) arr[i] = Math.random();
    const t0 = performance.now(); arr.sort((a,b)=>a-b); const t1 = performance.now();
    return { result:arr, time:t1 - t0, ops:size * Math.log2(size) };
  }},
  hash: { compute: function(params) {
    const iterations = params.n * 10; const results = [];
    const t0 = performance.now();
    for (let i = 0; i < iterations; i++) {
      const str = `block_${i}_${Math.random()}`; let hash = 0;
      for (let j = 0; j < str.length; j++) { hash = ((hash << 5) - hash) + str.charCodeAt(j); hash = hash & hash; }
      results.push(hash);
    }
    const t1 = performance.now();
    return { result:new Float32Array(results), time:t1 - t0, ops: iterations * 20 };
  }},
  monte: { compute: function(params) {
    const samples = params.n * params.n; let inside = 0;
    const t0 = performance.now();
    for (let i = 0; i < samples; i++) { const x = Math.random(), y = Math.random(); if (x*x + y*y <= 1) inside++; }
    const pi = (inside / samples) * 4; const t1 = performance.now();
    return { result:new Float32Array([pi]), time:t1 - t0, ops:samples * 4 };
  }},
};

/* ==================== ICE HELPERS ==================== */
async function waitIce(pc){
  if (pc.iceGatheringState === "complete") return;
  await new Promise(resolve => {
    const check = () => {
      if (pc.iceGatheringState === "complete") {
        pc.removeEventListener('icegatheringstatechange', check);
        resolve();
      }
    };
    pc.addEventListener('icegatheringstatechange', check);
  });
}

/* ==================== P2P CONNECTION ==================== */
class P2PConnection {
  constructor(role) {
    this.role = role;
    this.pc = null; this.dc = null;
    this.nodeId = "node_" + Math.random().toString(36).slice(2, 8);
    this.connectionReady = false; this.paused = false;
    this.pingInterval = null; this.lastPing = 0; this.latency = 0; this._tp = null;
  }
  
  async createPeer() {
    if (this.pc) this.close();
    log(`Creating peer connection as ${this.role}...`);
    this.pc = new RTCPeerConnection({
      iceServers: [
        {urls: "stun:stun.l.google.com:19302"},
        {urls: "stun:stun1.l.google.com:19302"}
      ],
      iceCandidatePoolSize: 10
    });
    this.setupEventHandlers();
    if (this.role === "coordinator") {
      // Reliable channel while debugging (remove maxRetransmits)
      this.dc = this.pc.createDataChannel("mesh", { ordered:true });
      this.dc.binaryType = "arraybuffer";
      this.wireDataChannel(this.dc);
    } else {
      this.pc.ondatachannel = (e) => {
        this.dc = e.channel; this.dc.binaryType = "arraybuffer";
        this.wireDataChannel(this.dc);
      };
    }
    pill($("#pc-state"), "new", "warn");
    pill($("#ice-state"), "new", "warn");
  }
  
  setupEventHandlers() {
    this.pc.onconnectionstatechange = () => {
      const s = this.pc.connectionState;
      pill($("#pc-state"), s, s==="connected"?"ok":(s==="failed"||s==="closed"?"bad":"warn"));
      log(`Connection state: ${s}`);
    };
    this.pc.oniceconnectionstatechange = () => {
      const s = this.pc.iceConnectionState;
      pill($("#ice-state"), s, (s==="connected"||s==="completed")?"ok":(s==="failed"||s==="disconnected"?"bad":"warn"));
      log(`ICE state: ${s}`);
    };
    let t=null;
    this.pc.onicecandidate = () => {
      if (t) clearTimeout(t);
      t = setTimeout(()=>{ if (this.pc.localDescription) $("#local").value = JSON.stringify(this.pc.localDescription); }, 300);
    };
  }
  
  wireDataChannel(channel) {
    channel.onopen = () => {
      pill($("#dc-state"), "open", "ok");
      log("‚úÖ Data channel open!");
      this.connectionReady = true;
      $("#btn-offer").disabled = false;
      $("#btn-pause").disabled = false;
      $("#btn-ping").disabled = false;
      if (this.role === "coordinator") {
        $("#btn-run").disabled = false; $("#btn-batch").disabled = false; $("#btn-stress").disabled = false;
      }
      this.send({ type:"HELLO", node_id:this.nodeId, role:this.role, capabilities:systemCaps.caps });
      this.startPing();
      // optional: initial throughput test
      this.runThroughputTest();
      showStatus("üéâ Connection established successfully!");
    };
    channel.onclose = () => {
      pill($("#dc-state"), "closed", "bad");
      log("Data channel closed");
      this.connectionReady = false; this.stopPing();
      $("#btn-run").disabled = true; $("#btn-batch").disabled = true; $("#btn-stress").disabled = true;
      $("#btn-pause").disabled = true; $("#btn-ping").disabled = true; $("#btn-offer").disabled = true;
    };
    channel.onerror = (e) => {
      log("‚ùå Data channel error:", e?.message || e);
      pill($("#dc-state"), "error", "bad");
    };
    channel.onmessage = (e) => this.onMessage(e);
    pill($("#dc-state"), "connecting", "warn");
  }

  startPing(){ this.pingInterval = setInterval(()=> this.send({type:"PING", timestamp: Date.now()}), 5000); }
  stopPing(){ if (this.pingInterval) { clearInterval(this.pingInterval); this.pingInterval=null; } }
  send(obj){ if (this.dc && this.dc.readyState==="open"){ this.dc.send(JSON.stringify(obj)); return true; } return false; }

  runThroughputTest(bytes=256*1024){
    if (!this.connectionReady || !this.dc) return;
    const nonce = Math.random().toString(36).slice(2);
    this._tp = { nonce, bytes, t0: performance.now() };
    this.send({ type:"THROUGHPUT_TEST", size:bytes, nonce, pad:"x".repeat(Math.max(0, bytes-64)) });
  }

  async createOffer() {
    if (!this.pc) await this.createPeer();
    const offer = await this.pc.createOffer();
    await this.pc.setLocalDescription(offer);
    showStatus("Gathering ICE candidates‚Ä¶");
    await waitIce(this.pc);
    $("#local").value = JSON.stringify(this.pc.localDescription);
    showStatus("Offer ready! Copy and send to worker.");
  }
  
  async createAnswer() {
    if (!this.pc || !this.pc.remoteDescription) return showStatus("‚ö†Ô∏è Set remote offer first!", true);
    const answer = await this.pc.createAnswer();
    await this.pc.setLocalDescription(answer);
    showStatus("Gathering ICE candidates‚Ä¶");
    await waitIce(this.pc);
    $("#local").value = JSON.stringify(this.pc.localDescription);
    showStatus("Answer ready! Send back to coordinator.");
  }
  
  async setRemoteDescription(descStr) {
    const desc = JSON.parse(descStr);
    if (!this.pc) await this.createPeer();
    await this.pc.setRemoteDescription(desc);
    log(`‚úÖ Remote ${desc.type} set`);
    if (desc.type==="offer" && this.role==="worker") showStatus("Offer set! Create your answer.");
    if (desc.type==="answer" && this.role==="coordinator") showStatus("Answer set! Connecting‚Ä¶");
  }
  
  async onMessage(ev) {
    // Robust parsing: ignore binary; guard JSON
    if (ev.data instanceof ArrayBuffer || ev.data instanceof Blob) return;
    let msg;
    try { msg = JSON.parse(ev.data); } catch(e){ return log("Bad JSON received"); }
    switch(msg.type){
      case "HELLO": log(`üì• HELLO from peer`); break;
      case "PING": this.send({ type:"PONG", timestamp: msg.timestamp }); break;
      case "PONG": {
        const rtt = Date.now() - msg.timestamp;
        pill($("#latency"), `${Math.max(0,Math.round(rtt/2))}ms`, rtt<100?"ok":"warn");
        break;
      }
      case "THROUGHPUT_TEST": this.send({ type:"THROUGHPUT_REPLY", size:msg.size, nonce:msg.nonce }); break;
      case "THROUGHPUT_REPLY": {
        if (this._tp && msg.nonce===this._tp.nonce){
          const dt=(performance.now()-this._tp.t0)/1000;
          const mbps=(msg.size*8)/(dt*1e6);
          pill($("#throughput"), `${mbps.toFixed(1)} Mb/s`, mbps>5?"ok":"warn");
          this._tp=null;
        }
        break;
      }
      case "RESOURCE_OFFER": log("üì• Resource offer:", msg); break;
      case "TASK": await this.handleTask(msg); break;
      case "RESULT": this.handleResult(msg); break;
      case "PAUSE": this.paused = true; log("‚è∏Ô∏è Worker paused"); break;
      case "RESUME": this.paused = false; log("‚ñ∂Ô∏è Worker resumed"); break;
      default: log(`Unknown message: ${msg.type}`);
    }
  }
  
  async handleTask(msg){
    stats.recv++; refreshStats();
    log(`üì• Task received: ${msg.task_type} size=${msg.params.n}`);
    if (this.paused){ this.send({ type:"RESULT", job_id:msg.job_id, status:"rejected", reason:"worker_paused" }); return; }
    const fn = (TaskTypes[msg.task_type] || TaskTypes.matmul).compute;
    const comp = fn(msg.params);
    const hashBuf = await crypto.subtle.digest("SHA-256", new Uint8Array(comp.result.buffer));
    const hex = Array.from(new Uint8Array(hashBuf)).map(b=>b.toString(16).padStart(2,"0")).join("");
    const result = { type:"RESULT", job_id:msg.job_id, task_type:msg.task_type, status:"completed",
      output_hash:hex, perf:{ ms:Math.round(comp.time), n:msg.params.n, gflops:(comp.ops/(comp.time*1e6)).toFixed(3) } };
    this.send(result); stats.completed++; refreshStats(); log(`üì§ Result sent: ${result.perf.gflops} GFLOPS`);
  }
  handleResult(msg){
    if (msg.status==="completed"){ stats.accepted++; perfTracker.addResult(msg); }
    else { log(`üì• Task rejected: ${msg.reason}`); }
    refreshStats();
  }
  close(){ try{this.dc?.close();}catch{} try{this.pc?.close();}catch{} this.dc=null; this.pc=null; this.connectionReady=false; }
}

/* ==================== GLOBAL STATE ==================== */
let role = "coordinator";
let connection = null;
let selectedTaskType = "matmul";
let jobCounter = 0;

const stats = { sent: 0, accepted: 0, recv: 0, completed: 0 };

function refreshStats() {
  pill($("#stat-sent"), stats.sent);
  pill($("#stat-accepted"), stats.accepted);
  pill($("#stat-recv"), stats.recv);
  pill($("#stat-completed"), stats.completed);
  if (perfTracker.stats.successfulTasks>0) {
    const avg = Math.round(perfTracker.stats.totalComputeTime / perfTracker.stats.successfulTasks);
    pill($("#stat-response"), `${avg}ms`);
  }
}

/* ==================== UI EVENT HANDLERS ==================== */
function resetUI() {
  $("#local").value = "";
  $("#remote").value = "";
  pill($("#pc-state"), "idle");
  pill($("#ice-state"), "idle");
  pill($("#dc-state"), "idle");
  pill($("#latency"), "N/A");
  pill($("#throughput"), "N/A");
  $("#btn-run").disabled = true;
  $("#btn-batch").disabled = true;
  $("#btn-stress").disabled = true;
  $("#btn-pause").disabled = true;
  $("#btn-ping").disabled = true;
  $("#btn-offer").disabled = true;
}
function updateInstructions() {
  const inst = $("#signal-instructions");
  inst.innerHTML = (role === "coordinator")
    ? "üì° <strong>Coordinator:</strong> Create offer ‚Üí Copy ‚Üí Send to worker"
    : "‚öôÔ∏è <strong>Worker:</strong> Paste offer ‚Üí Set remote ‚Üí Create answer ‚Üí Send back";
}

document.querySelectorAll("input[name=role]").forEach(r => {
  r.addEventListener("change", () => {
    role = r.value; log(`Role changed to ${role}`);
    if (connection) { connection.close(); connection = null; }
    connection = new P2PConnection(role);
    resetUI(); updateInstructions();
  });
});

document.querySelectorAll(".task-option").forEach(option => {
  option.addEventListener("click", () => {
    document.querySelectorAll(".task-option").forEach(o => o.classList.remove("selected"));
    option.classList.add("selected");
    selectedTaskType = option.dataset.type;
    log(`Task type: ${selectedTaskType}`);
  });
});

$("#btn-create").onclick = async () => {
  try {
    if (!connection) connection = new P2PConnection(role);
    if (role === "coordinator") await connection.createOffer();
    else await connection.createAnswer();
  } catch(e) { log(`Error: ${e.message}`); showStatus(`Error: ${e.message}`, true); }
};

$("#btn-remote").onclick = async () => {
  try {
    const raw = $("#remote").value.trim();
    if (!raw) return showStatus("Paste remote description first!", true);
    const desc = parseRemote(raw);
    if (!desc) return showStatus("Invalid remote (JSON / URL / base64)", true);
    if (!connection) connection = new P2PConnection(role);
    await connection.setRemoteDescription(desc);
  } catch(e) { log(`Error: ${e.message}`); showStatus(`Error: ${e.message}`, true); }
};

$("#btn-copy").onclick = async () => {
  const text = $("#local").value.trim();
  if (!text) return showStatus("Nothing to copy!", true);
  const ok = await safeCopy(text);
  showStatus(ok ? "‚úÖ Copied to clipboard!" : "Copy failed ‚Äî select and press Ctrl/Cmd+C", !ok);
};

$("#btn-reset").onclick = () => {
  if (connection) { connection.close(); connection = null; }
  resetUI(); log("Connection reset");
};

$("#btn-run").onclick = () => {
  if (!connection || !connection.connectionReady) return;
  jobCounter++;
  const task = { type: "TASK", job_id: `job_${jobCounter}`, task_type: selectedTaskType, params:{ n: parseInt($("#task-size").value) } };
  connection.send(task); stats.sent++; refreshStats();
};

$("#btn-batch").onclick = () => {
  if (!connection || !connection.connectionReady) return;
  const size = parseInt($("#task-size").value); const types = Object.keys(TaskTypes);
  for (let i = 0; i < 10; i++) {
    jobCounter++; const taskType = types[i % types.length];
    setTimeout(() => {
      const task = { type:"TASK", job_id:`batch_${jobCounter}`, task_type:taskType, params:{ n:size } };
      connection.send(task); stats.sent++; refreshStats();
    }, i * 100);
  }
};

$("#btn-stress").onclick = () => {
  if (!connection || !connection.connectionReady) return;
  showStatus("üî• Stress test running for 10 seconds...");
  const start = Date.now(); const sizes=[128,256,512]; const types=Object.keys(TaskTypes);
  const iv = setInterval(() => {
    if (Date.now() - start > 10000) { clearInterval(iv); showStatus("Stress test complete!"); return; }
    jobCounter++;
    const task = { type:"TASK", job_id:`stress_${jobCounter}`, task_type: types[Math.floor(Math.random()*types.length)], params:{ n: sizes[Math.floor(Math.random()*sizes.length)] } };
    connection.send(task); stats.sent++; refreshStats();
  }, 50);
};

$("#btn-pause").onclick = () => {
  if (!connection || !connection.connectionReady) return;
  connection.paused = !connection.paused;
  $("#btn-pause").textContent = connection.paused ? "‚ñ∂Ô∏è Resume Worker" : "‚è∏Ô∏è Pause Worker";
  connection.send({ type: connection.paused ? "PAUSE" : "RESUME" });
};

$("#btn-ping").onclick = () => { if (connection && connection.connectionReady) connection.send({ type:"PING", timestamp: Date.now() }); };

$("#btn-offer").onclick = () => {
  if (!connection || !connection.connectionReady) return;
  const offer = {
    type:"RESOURCE_OFFER", node_id:connection.nodeId,
    limits:{ concurrency:parseInt($("#concurrency").value), bandwidth_mbps:parseInt($("#bw").value) },
    capabilities:systemCaps.caps
  };
  connection.send(offer); $("#offer-status").textContent = "published ‚úì";
};

$("#btn-export").onclick = () => {
  const data = { timestamp:new Date().toISOString(), stats, performance:perfTracker.stats, history:perfTracker.history, capabilities:systemCaps.caps };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type:"application/json" });
  const url = URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download=`nyxmesh-stats-${Date.now()}.json`; a.click();
  showStatus("üìä Stats exported!");
};
$("#btn-clear-log").onclick = () => logger.clear();

/* ==================== INIT ==================== */
window.addEventListener('beforeunload', () => { if (connection) connection.close(); });

(async () => {
  await systemCaps.probe();
  connection = new P2PConnection(role);
  updateInstructions();
  log("üöÄ NyxMesh (Simplified) initialized");
  log(`Node ID: ${connection.nodeId}`);
  log(`Capabilities: ${systemCaps.caps.cores} cores, GPU: ${systemCaps.caps.gpu}`);
})();
</script>
</body>
</html>
